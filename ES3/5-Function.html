<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Function - Javascript Basic &amp; Detail</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="spacer"></li><li><a href="../basic/index.html"><strong aria-hidden="true">2.</strong> Basic</a></li><li><ol class="section"><li><a href="../basic/1-CallStack.html"><strong aria-hidden="true">2.1.</strong> CallStack</a></li><li><a href="../basic/2-Type.html"><strong aria-hidden="true">2.2.</strong> Type</a></li><li><a href="../basic/3-Function.html"><strong aria-hidden="true">2.3.</strong> Function</a></li><li><a href="../basic/4-Module.html"><strong aria-hidden="true">2.4.</strong> Module</a></li><li><a href="../basic/5-Event_Loop.html"><strong aria-hidden="true">2.5.</strong> Event Loop</a></li><li><a href="../basic/6-Async.html"><strong aria-hidden="true">2.6.</strong> Async</a></li><li><a href="../basic/7-Engine.html"><strong aria-hidden="true">2.7.</strong> Engine</a></li><li><a href="../basic/8-Bitwise_Operator.html"><strong aria-hidden="true">2.8.</strong> Bitwise Operator</a></li><li><a href="../basic/9-DOM.html"><strong aria-hidden="true">2.9.</strong> DOM</a></li><li><a href="../basic/10-Class.html"><strong aria-hidden="true">2.10.</strong> Class</a></li><li><a href="../basic/11-Call-Apply-Bind.html"><strong aria-hidden="true">2.11.</strong> Call-Apply-Bind</a></li><li><a href="../basic/12-Prototype.html"><strong aria-hidden="true">2.12.</strong> Prototype</a></li><li><a href="../basic/13-Object.create_Object.assign.html"><strong aria-hidden="true">2.13.</strong> Object.create Object.assign</a></li><li><a href="../basic/index.html"><strong aria-hidden="true">2.14.</strong> To be continue</a></li><li class="spacer"></li></ol></li><li><a href="../ES3/index.html"><strong aria-hidden="true">3.</strong> ES3 in Detail</a></li><li><ol class="section"><li><a href="../ES3/1-Execution_Contexts.html"><strong aria-hidden="true">3.1.</strong> Execution Contexts</a></li><li><a href="../ES3/3-This.html"><strong aria-hidden="true">3.2.</strong> This</a></li><li><a href="../ES3/4-ScopeChain.html"><strong aria-hidden="true">3.3.</strong> Scope Chain</a></li><li><a href="../ES3/5-Function.html" class="active"><strong aria-hidden="true">3.4.</strong> Function</a></li><li><a href="../ES3/6-Closure.html"><strong aria-hidden="true">3.5.</strong> Closure</a></li><li><a href="../ES3/index.html"><strong aria-hidden="true">3.6.</strong> To be continue</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <style>
  header.warning {
    background-color: rgb(242, 222, 222);
    border-bottom-color: rgb(238, 211, 215);
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border-bottom-style: solid;
    border-bottom-width: 0.666667px;
    border-image-outset: 0 0 0 0;
    border-image-repeat: stretch stretch;
    border-image-slice: 100% 100% 100% 100%;
    border-image-source: none;
    border-image-width: 1 1 1 1;
    border-left-color: rgb(238, 211, 215);
    border-left-style: solid;
    border-left-width: 0.666667px;
    border-right-color: rgb(238, 211, 215);
    border-right-style: solid;
    border-right-width: 0.666667px;
    border-top-color: rgb(238, 211, 215);
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    border-top-style: solid;
    border-top-width: 0.666667px;
    color: rgb(185, 74, 72);
    margin-bottom: 0px;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 30px;
    padding-bottom: 8px;
    padding-left: 14px;
    padding-right: 35px;
    padding-top: 8px;
    text-align: center;
  }
</style>


                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Javascript Basic &amp; Detail</h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#es3ecma-262-3-function" id="es3ecma-262-3-function"><h1>[ES3]ECMA-262-3 Function</h1></a>
<a class="header" href="#도입" id="도입"><h2>도입</h2></a>
<p>함수가 컨텍스트의 변수 객체(VO)에 어떠한 영향을 미치며, 각 함수의 스코프 체인에는 무엇이 들어가는지도 알아보자!!!</p>
<pre><code class="language-js">var foo = function () {...};

function foo() {...}

(function () {...})();
</code></pre>
<p>위와 같이 함수의 경우는 3가지가 있다.
<strong>선언식, 표현식, 즉시실행</strong></p>
<p>이 3가지의 차이점과 특징은 무엇인가에 대해서 자세히 알아볼 필요가 있다.
<br/></p>
<a class="header" href="#함수의-종류" id="함수의-종류"><h2>함수의 종류</h2></a>
<p><code>ECMAScript</code> 에는 세가지 종류의 함수가 있고, 각각의 고유한 특징을 갖는다.
<br/></p>
<a class="header" href="#함수-선언식" id="함수-선언식"><h3>함수 선언식</h3></a>
<p>함수 선언식(줄여서 FD)은 다음과 같은 특징을 갖는다.</p>
<ul>
<li>반드시 이름을 가진다.</li>
<li>소스 코드 위치에 자리한다. 프로그램 레벨이나 다른 함수의 몸체안에 직접 위치한다.</li>
<li>컨텍스트 <strong>진입 시점에 생성</strong> 한다.</li>
<li>변수 객체에 영향을 준다.</li>
</ul>
<pre><code class="language-js">function exampleFunc() {...}
</code></pre>
<p>가장 중요한 특징은 <strong>변수 객체에 영향을 미친다는 것이다.</strong>
이 함수는 컨텍스트의 변수 객체에 들어간다.</p>
<pre><code class="language-js">foo(); // 작동함

function foo() {
    alert('foo');
} 
</code></pre>
<p>위의 소스는 그렇다면 <code>Global</code> 의 <code>VO</code> 에 들어가 있을 것이다.(흔히 호이스팅이라 불리는 것)
<br/></p>
<p>소스 코드 내에 함수를 정의하는 위치 또한 중요하다.</p>
<pre><code class="language-js">// 함수를 다음 2가지 방법으로 선언할 수 있다.
// 1) 전역 컨텍스트에 직접.
function globalFD() {

    // 2) 또는 다른 함수의 몸체 내에서 선언.
    function innerFD() {}
}
</code></pre>
<p>함수를 선언할 수 있는 위치는 결국 두 군데가 있는 것이다.
<br/></p>
<a class="header" href="#함수-표현식" id="함수-표현식"><h3>함수 표현식</h3></a>
<p>함수 표현식(줄여서 FE)은 다음과 같은 함수다.</p>
<ul>
<li><strong>표현식 위치</strong>에만 정의할 수 있다.</li>
<li>선택적으로 이름을 가질 수 있다.(없을 수도 있다.)</li>
<li>함수 표현은 변수 객체에 영향을 주지 않는다.</li>
<li><strong>코드 실행 시점에 생성</strong> 한다.</li>
</ul>
<pre><code class="language-js">var foo = function () {...};
</code></pre>
<p>위의 경우는 익명함수 표현식을 <code>foo</code>변수에 할당하는 것이다.
할당이 끝나면 <code>foo</code> 를 호출할 수 있다. 선택적으로 이름을 줄 수 있다.</p>
<pre><code class="language-js">var foo = function _foo() {...};
</code></pre>
<p>여기에서 주목해야 할 것은 함수 내부에서 <code>_foo</code> 라는 이름을 사용할 수 있을 뿐만 아니라(외부는 사용불가), FE의 바깥에서도 식별자 <code>foo</code>에 접근할 수 있다는 사실이다.
<br/></p>
<p><code>FE</code>를 식별자에 할당하면 <code>FD</code>와 구분하기 어려워진다. 하지만 <code>FE</code>가 <strong>항상 표현식에 위치</strong> 한다는 사실을 알고 있다면, 둘을 쉽게 구분할 수 있다.
<br/></p>
<p>다음 예제에는 다양한 <code>ECMAScript</code> 표현식이 나와있는데, 모든 함수는 함수 표현식이다.</p>
<pre><code class="language-js">// 괄호(그룹화 연산자) 안에서는 표현식이 된다.
(function foo() {});

// 배열 리터럴 안에 있을 경우에도 표현식이다.
[function bar() {}];

// 콤마 또한 표현식으로 처리한다.
1, function baz() {};
</code></pre>
<p>위의 경우의 표현식들은, 표현식 위치에서 함수를 사용하고 변수 객체를 오염시키지 않으려면 필요하다.</p>
<pre><code class="language-js">function foo(callback) {
    callback();
}

foo(function bar() {alert('foo.bar');});
foo(function baz() {alert('foo.baz');});
</code></pre>
<p><code>FE</code>를 변수에 할당하면, 함수는 메모리에 계속 존재한다. 따라서 나중에 변수명으로 접근할 수 있다(알고 있듯이 변수가 변수 객체(VO)에 영향을 주기 때문). &lt;= 다시 말하지만 Global VO에 존재한다는 말이다.</p>
<pre><code class="language-js">var foo = function () {
    alert('foo');
};

foo();
</code></pre>
<p>보조적인 역할을 하는 도우미 데이터를 외부 컨텍스트에 감추기 위해서 유효범위를 캡슐화하는 예제가 있다(FE를 생성 직후 호출).</p>
<pre><code class="language-js">var foo = {};

(function initialize() {
    var x = 10;
    foo.bar = function () {   
        alert(x);
    };
})();

foo.bar(); // 10;

alert(x); // &quot;x&quot; is not defined
</code></pre>
<p>함수 <code>foo.bar</code> ( <code>foo</code> 의 <code>[[Scope]]</code> 프로퍼티에 있는)는 <code>initialize</code> 함수의 내부에 있는 변수 <code>x</code> 에 접근할 수 있다. 그리고 <code>x</code>는 외부에서 직접 접근할 수 없다.
<br/></p>
<p>많은 라이브러리가 <code>private</code> 데이터를 만들어서 보조 개체를 감추는 데 이 전략을 이용한다.
<br/></p>
<p>초기화하는 <code>FE</code> 의 이름을 종종 생략하기도 한다.</p>
<pre><code class="language-js">(function () {
    // 초기화 스코프
})();
</code></pre>
<p>런타임에 조건에 따라 FE를 생성함으로써 <code>VO</code>를 오염시키지 않는 예제도 있다.</p>
<pre><code class="language-js">var foo = 10;
var bar = (
    foo % 2 == 0 ? 
        function () { alert(0); }
        : 
        function () { alert(1); }
);

bar(); // 0
</code></pre>
<a class="header" href="#감싸는-괄호에-대한-질문" id="감싸는-괄호에-대한-질문"><h2>감싸는 괄호에 대한 질문</h2></a>
<p>이 부분은 개발을 오래한 것은 아니지만 1년동안 왜 괄호로 함수를 감싸야 선언과 동시에 호출할 수 있지 라는 생각을 했었다.
<br/></p>
<p><strong>그 답은 바로 표현식 구문이 가지는 제약 때문이었다.</strong>
<br/></p>
<p>표준에 따라서, 표현식 구문은 여는 중괄호, <code>{</code> 로 시작할 수 없다. 블럭과 구분할 수 없기 때문이다. 그리고 함수 선언과 구분하기 힘들기 때문에 함수 키워드로 시작해서도 안 된다.
<br/></p>
<p>다시 말해서, 즉시 실행 함수(function 키워드로 시작하는)를 만들기 위해서 아래와 같이 함수 선언식을 작성했다면,</p>
<pre><code class="language-js">function () {...}();// 또는 아래와 같이 이름이 있는.
function foo() {...}();
</code></pre>
<p>두 경우 모두 파서가 해석 에러를 보고할 것이다.
<br/></p>
<p>이 에러의 원인은 다양하겠지만, 전역 코드에 이렇게 선언을 하면(즉, 프로그램 레벨에), <code>function</code> 키워드로 시작하기 때문에 파서는 코드를 함수 선언식으로 이해한다.
<br/></p>
<p>첫번째 경우는 함수의 이름이 없기 때문에 <code>SyntaxError</code> 를 보고한다.
<br/></p>
<p>두 번째의 경우는 함수에 이름(<code>foo</code>)이 존재하기 때문에 파서가 정상적인 함수 선언으로 처리한다. 하지만 내부에 표현식이 없는 <strong>그룹화 연산자</strong> 를 사용하고 있음을 알리는 문법 에러가 발생한다. 이 경우에 함수 선언 뒤에 오는 것은 함수 호출을 위한 괄호가 아니라 <strong>그룹화 연산자일 뿐이다.</strong> 만약 코드를 다음과 같이 작성했다면,</p>
<pre><code class="language-js">// &quot;foo&quot;는 함수 선언이다
// 그리고 실행 컨텍스트 진입 시점에 생성한다.
alert(foo); 

// function
function foo(x) {
    alert(x);
}(1); // 이것은 호출이 아니라, 그룹화 연산자다.

foo(10); 
// 10
</code></pre>
<p>함수 선언과 표현식 <code>(1)</code>을 가지고 있는 그룹화 연산자가 있기 때문에 두 구문 모두 아무런 문제가 없다.
위의 예제는 아래의 예제와 같다.</p>
<pre><code class="language-js">// 함수 선언
function foo(x) {
    alert(x);
}
// 표현식이 있는 그룹화 연산자
(1);
// 다른 (function) 표현식을 갖는 또 다른 그룹화 연산자
(function () {});

// 내부에 있는 표현식
(&quot;foo&quot;);
</code></pre>
<p><code>ECMA</code> 스펙상으로 볼 때, 위의 코드는 잘못된 구문이다(표현식 구문은 <code>function</code> 키워드로 시작할 수 없다). 하지만 아래에 나와있는 것처럼, 문법 에러를 제공하는 <code>ECMAScript</code> 구현체는 하나도 없으며 모두 이를 각자 나름의 방식으로 처리한다.
<br/></p>
<p>지금까지 설명한 내용을 가지고, 어떻게 파서에게 함수를 생성과 동시에 실행하고 싶다고 이야기할 수 있을까?
<br/></p>
<p><strong>함수 선언식이 아닌 함수 표현식을 사용하면 된다.</strong>
<br/></p>
<p>표현식을 만드는 가장 간단한 방법은 위에서 이야기 했듯이 <strong>그룹화 연산자를 사용한다.</strong> 그룹화 연산자 안에 표현식을 두면, 파서는 함수 표현식(<code>FE</code>)인 코드를 구분할 수 있으며 이에 따라 모호함도 사라진다. 이러한 함수는 코드 실행 단계 동안에 만들어지고, 함수 실행이 끝난 후에는 사라진다(함수를 참조하고 있는 곳이 없다면).</p>
<pre><code class="language-js">(function foo(x) {
    alert(x);
})(1); // 이건 그룹화 연산자가 아닌 함수 호출이다.
</code></pre>
<p>예제의 마지막에 있는 괄호는 <code>FD</code>의 경우처럼 그룹화 연산자가 아니라 함수 호출 괄호다.
<br/></p>
<p>다음 예제에 나오는 즉시 호출 함수는 괄호로 감쌀 필요가 없다는 것에 주목하자. 이유는 함수가 표현식의 위치에 있어서 파서가 이를 코드 실행 시점에 생성하는 <code>FE</code>로 처리해야 한다는 것을 이미 알고 있기 떄문이다.</p>
<pre><code class="language-js">var foo = {
    bar: function (x) {   
        return x % 2 != 0 ? 'yes' : 'no';
    }(1)
};

alert(foo.bar); // 'yes'
</code></pre>
<p>얼핏보면 <code>foo.bar</code>는 함수가 아니라 문자열처럼 보인다. 여기에 있는 함수는 프로퍼티를 초기화할 때만 사용하는데, 조건 매개변수 값에 따라서 값을 돌려주는 함수를 만들고 바로 실행한다. 따라서, <code>괄호</code> 를 묻는 질문에 완벽한 대답은 다음과 같다.</p>
<p>:star: <strong>제일 중요한 부분</strong> :star:</p>
<blockquote>
<p><strong>그룹화 괄호는 함수가 표현식의 위치에 있지 않을 때 필요하고, 함수를 생성 후 즉시 실행하고 싶은 경우에는 직접 함수를 FE로 변환한다.</strong></p>
</blockquote>
<p>괄호를 감싸는 방법 외에 함수를 FE 타입으로 변경할 수 있는 다른 방법이 있다. 예를 들어,</p>
<pre><code class="language-js">1, function () { 
    alert('익명함수를 호출합니다.');
}();// 또는 이렇게,

!function () { 
    alert('ECMAScript');
}();// 그리고 수동적으로 변경하는 다른 방법들...
</code></pre>
<p>올바른 표현식</p>
<pre><code class="language-js">(function () {})();
(function () {}());
</code></pre>
<a class="header" href="#구현의-확장--function문" id="구현의-확장--function문"><h2>구현의 확장 : Function문</h2></a>
<p>다음에 나오는 예제 코드는 어떤 <code>ECMAScript</code> 구현체도 명세를 따르지 않았음을 보여준다.</p>
<pre><code class="language-js">if (true) { 
    function foo() {   
        alert(0); 
    }
} else { 
    function foo() {   
        alert(1); 
    }
}
    
foo(); // 1 또는 0? 다른 ECMAScript 엔진에서 테스트 해보자.
</code></pre>
<p>표준에 비춰볼 때 이 구조는 문제가 있다. 코드 블럭 안에 함수 선언식(<code>FD</code>)을 둘 수 없기 때문이다(지금은 <code>if</code>와 <code>else</code>가 <code>FD</code>를 가지고 있음). 위에서 이야기 했듯이, <code>FD</code>는 프로그램 레벨이나 다른 함수의 몸체 안에 직접 위치해야 한다.
<br/></p>
<p>코드 블럭은 오직 구문만 가질 수 있기 때문에 위의 예제는 잘못되었다. 블럭 내에 함수는 표현식의 위치에만 나올 수 있으며, 함수를 정의할 때는 여는 중괄호(코드 블럭과 구분할 수 없음)나 함수 키워드로 시작할 수 없다(<code>FD</code>와 구분할 수 없음).
<br/></p>
<p>하지만 표준 문서의 <code>error processing</code> 섹션은 <code>ECMAScript</code> 구현체가 프로그램 구문을 확장할 수 있도록 허용하고 있다. 그리고 블럭 안에 등장하는 함수 처리가 이러한 확장 중에 하나다. 오늘날 존재하는 모든 구현체는 이 경우에 예외를 던지지 않고 각자 고유의 방식으로 처리한다.
<br/></p>
<p>위 예제의 <code>if-else</code> 분기문은 두 함수 중 어떤 것을 정의할지 선택할 수 있다고 가정한다. 이 결정은 런타임에 이루어지기 때문에, 함수 표현식(<code>FE</code>)을 사용해야 한다. 하지만 대부분의 구현체는 단순하게 컨텍스트 진입 시점에 두 개의 함수 선언식(<code>FD</code>)을 모두 생성한다. 두 함수 모두 같은 이름을 사용하기 때문에, 마지막에 선언한 함수만 호출할 수 있다. 이런 이유로 이 예제를 실행하면 <code>else</code> 로 코드 제어가 이동할 수 없음에도 불구하고 <code>foo</code> 함수는 1을 출력한다.
<br/></p>
<a class="header" href="#기명함수-표현식의-특징named-function-expression-nfe" id="기명함수-표현식의-특징named-function-expression-nfe"><h2>기명함수 표현식의 특징(Named Function Expression, NFE)</h2></a>
<p>이름을 갖는 <code>FE</code>(기명 함수 표현식, 줄여서 NFE)는 중요한 특징 하나를 가지고 있다.<br />
<br/></p>
<p>함수 표현식을 정의할 때 이야기 했던 것처럼</p>
<ul>
<li>함수 표현식은 컨텍스트의 변수 객체에 영향을 주지 않는다</li>
<li>하지만 FE는 이름으로 자기 자신을 재귀 호출할 수 있다.</li>
</ul>
<pre><code class="language-js">(function foo(bar) {
 if (bar) {
   return;
 }
 foo(true); // &quot;foo&quot; 이름을 이용할 수 있다.
})();
// 하지만 외부에서는 &quot;foo&quot;를 이용할 수 없다.  
foo(); // &quot;foo&quot; is not defined
</code></pre>
<p><code>foo</code> 를 어디에 보관하는 걸까? <code>foo</code>의 활성화 객체 안도 아니다. <code>foo</code> 함수 내부에서 <code>foo</code>라는 이름을 정의한 적이 없다. 그렇다면 <code>foo</code> 를 생성하는 컨텍스트의 변수객체 안도 역시 아니다. <code>FE</code>는 <code>VO</code>에 영향을 주지 않는다는 사실을 외부에서 <code>foo</code> 를 호출하면서 확인했다.  그렇다면 어디일까?
<br/></p>
<p>코드 실행 시점에 인터프리터가 기명 함수 표현식(<code>NFE</code>)을 만나면. 함수 표현식을 만들기 전에 <strong>보조 특수 객체(auxiliary specilal object)</strong> 를 만들고 스코프 체인의 <strong>가장 앞에 이 특수 객체를 추가</strong> 한다. 그런 다음에  함수 표현식을 만드는데, 이 때 함수에 <code>[[Scope]]</code> 프로퍼티(Scope chain에서 배웠듯이)가 생긴다. 여기에는 함수를 생성하는 컨텍스트의 스코프 체인이 들어있다(즉, <code>[[Scope]]</code> 안에 특수 객체가 위치한다). 다음으로, 기명 함수 표현식을 특수 객체에 고유 프로퍼티로 추가한다. 이 프로퍼티의 값은 함수 표현식을 참조한다. 그리고 마지막으로 부모의 스코프 체인에서 특수 객체를 제거한다.</p>
<pre><code class="language-js">specialObject = {};

Scope = specialObject + Scope;

foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}

delete Scope[0]; // 스코프 체인의 가장 앞에 있는 specialObject를 삭제한다.
</code></pre>
<p>따라서, 외부에서는 이 함수의 이름을 사용할 수 없다. 함수의 <code>[[Scope]]</code> 안에 특수 객체가 저장되어 있기 때문에, 내부에서는 이 함수의 이름을 사용할 수 있다.
<br/></p>
<a class="header" href="#마무리" id="마무리"><h2>마무리</h2></a>
<p>생각보다 내용이 많아졌다. 나도 선언식, 표현식을 비교하면서 보여주는 블로그들은 많이 봤지만 정확히 왜 그렇게 되고 즉시실행은 왜 저렇게 될 수 밖에 없는 것인가에 대해서 정리를 해보았다. 자꾸자꾸 보면서 쉬운말로 고쳐봐야겠다.</p>
<hr />
<a class="header" href="#reference" id="reference"><h4>Reference</h4></a>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/">chapter-5-functions</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../ES3/4-ScopeChain.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../ES3/6-Closure.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../ES3/4-ScopeChain.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../ES3/6-Closure.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
