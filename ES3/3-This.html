<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>This - Javascript Basic &amp; Detail</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../basic/index.html"><strong aria-hidden="true">2.</strong> Basic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic/1-CallStack.html"><strong aria-hidden="true">2.1.</strong> Call Stack</a></li><li class="chapter-item expanded "><a href="../basic/2-Type.html"><strong aria-hidden="true">2.2.</strong> Type</a></li><li class="chapter-item expanded "><a href="../basic/3-Function.html"><strong aria-hidden="true">2.3.</strong> Function</a></li><li class="chapter-item expanded "><a href="../basic/4-Module.html"><strong aria-hidden="true">2.4.</strong> Module</a></li><li class="chapter-item expanded "><a href="../basic/5-Event_Loop.html"><strong aria-hidden="true">2.5.</strong> Event Loop</a></li><li class="chapter-item expanded "><a href="../basic/6-Async.html"><strong aria-hidden="true">2.6.</strong> Async</a></li><li class="chapter-item expanded "><a href="../basic/7-Engine.html"><strong aria-hidden="true">2.7.</strong> Engine</a></li><li class="chapter-item expanded "><a href="../basic/8-Bitwise_Operator.html"><strong aria-hidden="true">2.8.</strong> Bitwise Operator</a></li><li class="chapter-item expanded "><a href="../basic/9-DOM.html"><strong aria-hidden="true">2.9.</strong> DOM</a></li><li class="chapter-item expanded "><a href="../basic/10-Class.html"><strong aria-hidden="true">2.10.</strong> Class</a></li><li class="chapter-item expanded "><a href="../basic/11-Call-Apply-Bind.html"><strong aria-hidden="true">2.11.</strong> Call, Apply, Bind</a></li><li class="chapter-item expanded "><a href="../basic/12-Prototype.html"><strong aria-hidden="true">2.12.</strong> Prototype</a></li><li class="chapter-item expanded "><a href="../basic/13-Object.create_Object.assign.html"><strong aria-hidden="true">2.13.</strong> Object.create, Object.assign</a></li><li class="chapter-item expanded "><a href="../basic/14-Map-Filter-Reduce.html"><strong aria-hidden="true">2.14.</strong> Map, Filter, Reduce</a></li><li class="chapter-item expanded "><a href="../basic/15-Pure-Functions-Side-Effects-State-Mutation.html"><strong aria-hidden="true">2.15.</strong> Pure Functions, Side Effects, State Mutation</a></li><li class="chapter-item expanded "><a href="../basic/index.html"><strong aria-hidden="true">2.16.</strong> To be continue</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../ES3/index.html"><strong aria-hidden="true">3.</strong> ES3 in Detail</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ES3/1-Execution_Contexts.html"><strong aria-hidden="true">3.1.</strong> Execution Contexts</a></li><li class="chapter-item expanded "><a href="../ES3/3-This.html" class="active"><strong aria-hidden="true">3.2.</strong> This</a></li><li class="chapter-item expanded "><a href="../ES3/4-ScopeChain.html"><strong aria-hidden="true">3.3.</strong> Scope Chain</a></li><li class="chapter-item expanded "><a href="../ES3/5-Function.html"><strong aria-hidden="true">3.4.</strong> Function</a></li><li class="chapter-item expanded "><a href="../ES3/6-Closure.html"><strong aria-hidden="true">3.5.</strong> Closure</a></li><li class="chapter-item expanded "><a href="../ES3/index.html"><strong aria-hidden="true">3.6.</strong> To be continue</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../core-javascript/index.html"><strong aria-hidden="true">4.</strong> 코어 자바스크립트</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../core-javascript/1-데이터-타입.html"><strong aria-hidden="true">4.1.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="../core-javascript/2-실행-컨텍스트.html"><strong aria-hidden="true">4.2.</strong> 실행 컨텍스트</a></li><li class="chapter-item expanded "><a href="../core-javascript/3-this.html"><strong aria-hidden="true">4.3.</strong> this</a></li><li class="chapter-item expanded "><a href="../core-javascript/5-Closure(클로저).html"><strong aria-hidden="true">4.4.</strong> 클로저</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Javascript Basic &amp; Detail</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ecma-262-3-this"><a class="header" href="#ecma-262-3-this">ECMA-262-3 This</a></h1>
<blockquote>
<p><a href="https://seonhyungjo.github.io/Javascript-Book/ES3/1-Execution_Contexts.html">실행컨텍스트</a> 선행이 필요합니다.</p>
</blockquote>
<p>이번 주제는 <code>this</code> 키워드이다. </p>
<p>이 주제는 상당히 어려워서 종종 다른 실행 컨텍스트의 <code>this</code> 값을 처리할 때 이슈를 만들곤 한다.</p>
<h2 id="정의"><a class="header" href="#정의">정의</a></h2>
<p><code>this</code>는 <strong>실행 컨텍스트의 프로퍼티</strong>다.</p>
<pre><code class="language-js">activeExecutionContext = {
  VO: {...},
  this: thisValue // 다른 하나가 더 있다. scope, 총 3개로 구성되어 있다.
};
</code></pre>
<p>여기의 <code>VO</code> 는 <em>변수 객체(Variable object)를 의미</em> 한다.</p>
<p><code>this</code> 는 컨텍스트의 실행 코드 타입과 직접적인 관련이 있다. 
<strong>이 값은 컨텍스트로 진입하는 과정에서 정해지며, 컨텍스트 안의 코드가 실행 중에는 변하지 않는다.</strong></p>
<p>좀 더 자세하게 들여다보자.</p>
<p>전역 코드 안의 <code>this(This value in the global code)</code> 이건 정말 단순하다. 전역이니까 당연히 <code>this</code> 는 전역객체 <strong>자신(global 또는 window)</strong> 이 될 것이다.</p>
<pre><code class="language-js">// 명시적인 전역 객체 프로퍼티 정의
this.a = 10; // global.a = 10
alert(a); // 10

// 규정되지 않은 식별자 할당을 이용한 암묵적 정의
b = 20;
alert(this.b); // 20

// 전역 컨텍스트의 변수 객체는 전역 객체 자신이기 때문에
// 또한 변수 선언을 이용한 암묵적 정의도 가능하다.
var c = 30;
alert(this.c); // 30
</code></pre>
<p>함수 코드 안의 <code>this(This value in the function code)</code> 이제부터가 진짜라고 할 수 있다. 함수타입의 코드의 <code>this</code> 는 함수에 정적으로 바인딩이 되지 않는다는 것이다.</p>
<p>컨텍스트로 들어갈 때 정해지며, 함수코드의 <code>this</code> 는 매번 바뀔 수 있다. </p>
<p>그러나 코드나 코드가 실행되고 <code>this</code> 는 변경이 이루어질 수 없다(이 얘기는 아래에서 또 나온다.).</p>
<p>즉 <code>this</code>를 재할당하는 것이 불가능하다는 것이다.</p>
<pre><code class="language-js">var foo = {x: 10};
var bar = {
  x: 20,
  test: function () {   
  alert(this === bar); 
    // true   
    alert(this.x); // 20   
    this = foo; // 에러, this 값을 변경할 수 없다.   
    alert(this.x); // 
    // 만약 위에서 에러가 나지 않았다면 20이 아닌 10이 출력될 것이다.
  }
};
// 컨텍스트로 들어올 때 this가 가리키는 대상이 bar 객체로 결정된다.
// 왜 그러한지는 아래에서 자세하게 설명하겠다.
bar.test(); // true, 20
foo.test = bar.test;
// 그러나 여기의 this는 이제 foo를 참조할 것이다.  
// 심지어 같은 함수를 호출하는 데도 말이다.
foo.test(); // false, 10
</code></pre>
<p>그렇다면 어떻게 해야 this가 바뀌는 것일까?</p>
<p>컨텍스트의 코드를 활성화한 <strong>호출자(caller)에 의해</strong> 제공된다. </p>
<p>즉 함수를 호출한 부모 컨텍스트가 존재한다는 것이다. 어떤 컨텍스트의 <code>this</code>가 참조하는 값을 어려움 없이 알아내기를 원한다면 중요한 이 부분을 이해하고 기억해야 한다. </p>
<p>정확하게 호출 표현식의 형태, <strong>즉 다른 무엇이 아닌 함수를 호출한 방법이 호출된 컨텍스트</strong>의 <code>this</code> 값에 영향을 준다.</p>
<blockquote>
<p><code>this</code> 값은 함수가 어떻게 정의되었는가에 따라 정해진다. 전역 함수라면 <code>this</code> 는 전역 객체를 값으로 갖게 되고, 객체의 메서드라면 <code>this</code> 는 항상 이 객체를 값으로 갖는다.</p>
</blockquote>
<pre><code class="language-js">function foo() {
  console.log(this);
}

foo(); // global

console.log(foo === foo.prototype.constructor); // true

foo.prototype.constructor(); // foo.prototype
</code></pre>
<p>위의 코드가 무슨 의미인지 모를 수 있다.</p>
<p>먼저 <code>foo === foo.prototype.constructor</code> 이 부분을 보면 전역 함수인 <code>foo</code> 가 <code>foo.prototype.constructor</code> 가 같으므로 둘 다 전역이라고 생각할 수 있다. </p>
<p>그렇다면 <code>foo.prototype.constructor</code> 를 실행하게 되면, 당연히 <code>this</code> 는 <code>global</code>이 되어야 한다고 생각한다. </p>
<p>그러나 실제 결과는 다르다! 이것과 유사하게 어떤 객체의 메서드로 정의된 함수를 호출하는 경우에서도 <code>this</code> 가 달라질 수 있다.</p>
<pre><code class="language-js">var foo = {
  bar: function () {   
    console.log(this);   
    console.log(this === foo);
  }
};

foo.bar(); // foo, true

var exampleFunc = foo.bar;
console.log(exampleFunc === foo.bar); // true

exampleFunc(); // global, false
</code></pre>
<p>이 경우도 똑같다고 생각하면 된다. <code>exampleFunc === foo.bar</code> 의 결과가 같다면 <code>this</code> 는 같은 것이 나올거라 일반적으로 생각을 할 것이다. </p>
<p>그런데 결과를 보게 되면 놀랍다. <code>global</code>이 나온다.</p>
<p>그렇다면 <strong>호출 표현식의 형태</strong>가 어떻게 <code>this</code> 에 영향을 미칠까? </p>
<p><code>this</code> 가 갖는 값을 결정하는 과정을 완벽하게 이해하기 위해서, 내부 타입 중에 하나인 <strong>레퍼런스 타입(Reference type)</strong> 에 대해서 자세하게 알 필요가 있다.</p>
<h2 id="레퍼런스-타입"><a class="header" href="#레퍼런스-타입">레퍼런스 타입</a></h2>
<p>레퍼런스 타입은 수도 코드를 이용해서 <code>base</code> (프로퍼티가 속해 있는 객체)와 이 <code>base</code> 안에 있는 <code>propertyName</code> 이라는 2개의 프로퍼티를 가진 객체로 나타낼 수 있다.</p>
<pre><code class="language-js">var valueOfReferenceType = {
  base: &lt;base object&gt;,
  propertyName: &lt;property name&gt;
};
</code></pre>
<p>레퍼런스 타입의 값은 오직 아래의 2가지 경우에만 있을 수 있다. 내가 볼 때 아래에 2가지 경우가 <code>this</code> 를 이해하는데 핵심이다.</p>
<pre><code>1. 식별자(identifier)를 다룰 때
2. 프로퍼티 접근자(property accessor)를 다룰 때.
</code></pre>
<p>식별자는 알고리즘이 항상 레퍼런스 타입 값(<code>this</code>와 관련해서 중요하다)을 결과로 돌려준다는 것만 명심하자.</p>
<p><em>식별자는 변수 이름, 함수 이름, 함수 전달인자의 이름 그리고 전역 객체의 비정규화 프로퍼티의 이름을 뜻한다.</em></p>
<pre><code class="language-js">var foo = 10; // 변수이름
function bar() {} // 함수이름
</code></pre>
<p>중간결과는 아래와 같이 될 것이다.</p>
<pre><code class="language-js">var fooReference = {
  base: global,
  propertyName: 'foo'
};

var barReference = {
  base: global,
  propertyName: 'bar'
};
</code></pre>
<p>레퍼런스 타입 값으로부터 객체가 가진 실제 값을 얻기 위해 쓰이는 <code>GetValue</code> 메서드가 있는데 이 메서드를 수도 코드로 아래와 같이 나타낼 수 있다.</p>
<pre><code class="language-js">function GetValue(value) {
  if (Type(value) != Reference) {   
    return value;    // 레퍼런스 타입이 아니면 값을 그대로 돌려준다.
  }
  
  var base = GetBase(value);
  
  if (base === null) {   
    throw new ReferenceError;
  }
  
  return base.[[Get]](GetPropertyName(value))
}
</code></pre>
<p>위에서 내부 <code>[[Get]]</code> 메서드는 프로토타입 체인으로부터 상속된 프로퍼티까지 분석해서 <strong>객체 프로퍼티의 실제 값</strong> 을 돌려준다.</p>
<pre><code class="language-js">GetValue(fooReference); // 10
GetValue(barReference); // function object &quot;bar&quot;
</code></pre>
<p><strong>(중요)프로퍼티 접근자는 점 표기법(프로퍼티 이름이 정확한 식별자이고 미리 알 수 있을 때)이나 대괄호 표기법의 2가지 방법으로 표기할 수 있다.</strong></p>
<pre><code class="language-js">foo.bar();
foo['bar']();
</code></pre>
<p>이번에도 중간 계산의 결과로 레퍼런스 타입의 값을 갖게 된다.</p>
<pre><code class="language-js">var fooBarReference = { 
  base: foo, 
  propertyName: 'bar'
};

GetValue(fooBarReference); // function object &quot;bar&quot;
</code></pre>
<p>그렇다면, 레퍼런스 타입의 값과 함수 컨텍스트의 <code>this</code> 값은 어떤 관계일까? <strong>이 부분이 가장 중요하며, 이 글의 메인이다</strong>. </p>
<p>함수 컨텍스트의 <code>this</code> 값을 결정하는 일반적인 규칙은 다음과 같이 말할 수 있다.</p>
<p>함수 컨텍스트의 <code>this</code> 값은 호출자가 제공하며 <strong>호출 표현식의 현재 형태에 의해서 그 값이 결정된다</strong>(함수 호출이 문법적으로 어떻게 이뤄졌는지에 따라서).</p>
<p>호출 괄호(…)의 왼편에 레퍼런스 타입의 값이 존재하면, <strong><code>this</code> 는 레퍼런스 타입의 <code>this</code> 값인 <code>base</code> 객체를 값으로 갖는다.</strong></p>
<p>다른 모든 경우에는(레퍼런스 타입이 없는 다른 모든 값의 경우), <code>this</code> 값은 항상 <code>null</code>로 설정된다. 그러나 <code>null</code> 은 <code>this</code> 의 값으로 의미가 없기 때문에 암묵적으로 전역 객체로 변환된다.</p>
<p>예제</p>
<pre><code class="language-js">function foo() {
 return this;
}
foo(); // global
</code></pre>
<p>호출 괄호 왼쪽에 레퍼런스 타입 값이 있다. (<code>foo</code> 는 함수이름으로 식별자이다)</p>
<pre><code class="language-js">var fooReference = {
 base: global,
 propertyName: 'foo'
};
</code></pre>
<p>따라서, <code>this</code> 값은 레퍼런스 타입 값의 <code>base</code> 객체인 전역 객체로 설정된다.</p>
<pre><code class="language-js">var foo = {
 bar: function () {
   return this;
 }
};
foo.bar(); // foo
</code></pre>
<p>여기에서 다시 <code>base</code> 가 <code>foo</code> 객체인 레퍼런스 타입의 값을 갖게 되고, 이것은 <code>bar</code> 함수 활성화 시에 <code>this</code> 값으로 이용된다.</p>
<pre><code class="language-js">var fooBarReference = {
 base: foo,
 propertyName: 'bar'
};
</code></pre>
<p>그러나, 또 다른 형태의 호출 표현식으로 함수를 활성화하면 <code>this</code> 값은 달라진다.</p>
<pre><code class="language-js">var test = foo.bar;
test(); // global
</code></pre>
<p><code>test</code> 가 식별자가 되면서 다른 레퍼런스 타입 값을 만들기 때문에, 이 레퍼런스 타입의 <code>base</code> (전역 객체)가 <code>this</code> 값으로 사용된다.</p>
<pre><code class="language-js">var testReference = {
 base: global,
 propertyName: 'test'
};
</code></pre>
<p>이제는 다른 형태의 호출 표현식으로 활성화된 같은 함수가, 또한 다른 <code>this</code> 값을 갖는지를 정확하게 이야기할 수 있다
=&gt; <strong>레퍼런스 타입의 중간값이 달라서 일어나는 현상</strong></p>
<pre><code class="language-js">function foo() {
 alert(this);
}
foo(); // 전역이기 때문에

var fooReference = {
 base: global,
 propertyName: 'foo'
};

alert(foo === foo.prototype.constructor); // true

// 호출 표현식의 또 다른 형태
foo.prototype.constructor(); // foo.prototype이기 때문에

var fooPrototypeConstructorReference = {
 base: foo.prototype,
 propertyName: 'constructor'
};
</code></pre>
<p>호출 표현식 형태에 따라 <code>this</code> 값이 동적으로 결정되는 또 다른 예제가 있다.</p>
<pre><code class="language-js">function foo() {
 alert(this.bar);
}

var x = {bar: 10};
var y = {bar: 20};

x.test = foo;
y.test = foo;

x.test(); // 10
y.test(); // 20
</code></pre>
<h2 id="함수-호출과-비-레퍼런스-타입function-call-and-non-reference-type"><a class="header" href="#함수-호출과-비-레퍼런스-타입function-call-and-non-reference-type">함수 호출과 비-레퍼런스 타입(Function call and non-Reference type)</a></h2>
<p>호출 괄호의 왼편에 레퍼런스 타입이 아닌 다른 값이 오는 경우 <code>this</code> 값은 자동으로 <code>null</code> 값을 가지게 된다. 그리고 이것을 엔진은 자동으로 전역 객체로 출력한다.</p>
<pre><code class="language-js">(function () {
 alert(this); // null =&gt; global
})();
</code></pre>
<p>딱 위의 경우가 좋은 예시이다. 이것은 레퍼런스타입(식별자, 프로퍼티 접근자)가 아니다. 따라서 레퍼런스타입이 존재하지 않는다. 즉 <code>null</code> 이다 그러므로 전역객체를 출력한다.</p>
<pre><code class="language-js">var foo = {
 bar: function () {
   alert(this);
 }
};

foo.bar(); // Reference, OK =&gt; foo
(foo.bar)(); // Reference, OK =&gt; foo

(foo.bar = foo.bar)(); // global?
(false || foo.bar)(); // global?
(foo.bar, foo.bar)(); // global?
</code></pre>
<p>이 경우가 정말 어렵다. 왜 아래의 <strong>3개의 경우에는 왜 전역객체가 나오는 것일까?</strong></p>
<p>즉 아래의 3개는 레퍼런스 타입 값이 <code>null</code>이라는 것이다.</p>
<p>두번째 경우에는 <strong>그룹핑 연산자</strong>가 레퍼런스 타입의 값으로부터 객체의 실제 값을 얻기 위한 메서드인 <code>GetValue</code> 에 적용되지 않는다. 그래서 그룹핑 연산자가 평가 결과를 반환할 때도 여전히 레퍼런스 타입의 값이 존재 하게 되는데, 이것이 this 값이 다시 <code>base</code> 객체로 설정되는 이유다.</p>
<p>세번째의 경우는, <strong>그룹핑 연산자와 다르게 할당 연산자는 GetValue 메서드를 호출한다.</strong> 반환의 결과로 <code>this</code> 가 <code>null</code>로 설정되었음을 의미하는 함수 객체(레퍼런스 타입 값은 아닌)가 반환되기 때문에, 이는 결국 전역 객체가 된다.</p>
<p>네번째와 다섯번째의 경우도 유사하다. <strong>콤마 연산자와 논리적 OR 표현식</strong>은 <code>GetValue</code> 메서드를 호출하고, 따라서 레퍼런스 타입의 값을 잃어버리고 함수 타입의 값을 갖게 되어 <code>this</code> 의 값은 전역 객체로 설정된다.</p>
<p>레퍼런스 타입과 값이 <code>null</code> 인 <strong>this(Reference type and null this value)</strong> 위에도 말은 했지만 레퍼런스타입의 값이 <strong>null이 되면 this는 전역객체가 된다고 했다.</strong> 이것은 레퍼런스 타입 값의 base 객체가 활성화 객체인 경우와 관련이 있다.</p>
<pre><code class="language-js">function foo() {
 function bar() {
   alert(this); // global
 }
 bar(); // AO.bar()와 같다.
}
</code></pre>
<p><strong>활성화 객체는 항상 this 값으로 null을 반환한다.</strong></p>
<h2 id="예외의-with함수"><a class="header" href="#예외의-with함수">예외의 with함수</a></h2>
<p><code>with</code> 객체가 함수 이름 프로퍼티를 갖는 경우, <code>with</code> 문의 블록 안에서 함수를 호출할 때는 예외일 수 있다. <code>with</code> 문은 자신의 스코프 체인의 가장 앞, 즉 활성화 객체 앞에 그 객체를 추가한다. </p>
<p>따라서 레퍼런스 타입 값을 얻으려 할 때(식별자나 프로퍼티 접근자를 이용해서) 활성화 객체가 아닌 <code>with</code> 문의 객체를 <code>base</code> 객체로 갖게 된다.</p>
<p>그런데, 이는 <code>with</code> 객체가 스코프 체인에서 더 상위에 있는(전역 객체 또는 활성화 객체) 객체까지 가려버리기 때문에 중첩함수뿐만 아니라 전역 함수와도 관련이 있다.</p>
<pre><code class="language-js">var x = 10;
with ({
 foo: function () {
   alert(this.x);
 },
 x: 20
}) {
 foo(); // 20
}
// because
var  fooReference = {
 base: __withObject,
 propertyName: 'foo'
};
</code></pre>
<p><code>catch</code> 절의 실제 파라미터인 함수를 호출할 것도 이와 유사하다. </p>
<p>이 경우에 항상 스코프 체인의 가장 앞, 즉 활성화 객체나 전역 객체 앞에 <code>catch</code> 객체가 추가된다. </p>
<p>그러나 이 동작은 <code>ECMA-262-3</code> 의 버그로 인정되어 새로운 버전인 <code>ECMA-262-5</code>에서는 수정된다. <code>ECMA-262-5</code>는 이러한 경우 <code>this</code> 값이 <code>catch</code> <strong>객체가 아닌 전역 객체로 설정된다.</strong></p>
<pre><code class="language-js">try {
 throw function () {
   alert(this);
 };
} catch (e) {
 e(); // __catchObject - ES3, global - ES5에서는 수정
}
// on idea
var eReference = {
 base: __catchObject,
 propertyName: 'e'
};
// 그러나, 이것은 버그이기 때문에
// this는 강제로 전역 객체를 참조하게 된다.
// null =&gt; global
var eReference = {
   base : global,
   propertyName: 'e'
}
</code></pre>
<h2 id="생성자로-호출된-함수-안의-thisthis-value-in-function-called-as-the-constructor"><a class="header" href="#생성자로-호출된-함수-안의-thisthis-value-in-function-called-as-the-constructor">생성자로 호출된 함수 안의 this(This value in function called as the constructor)</a></h2>
<pre><code class="language-js">function A() {
 alert(this); // 새롭게 만들어진 객체, 아래에서 a 객체
 this.x = 10;
}

var a = new A();
alert(a.x); // 10
</code></pre>
<p>이 경우는, <code>new</code> 연산자가 A함수의 내부 [[Construct]] 메서드를 호출하고 차례로, 객체가 만들어진 후에 A와 모두 같은 함수인 내부의 [[Call]] 메서드를 호출하여 <code>this</code> 값으로 새롭게 만들어진 객체를 갖게 된다.</p>
<h2 id="함수-호출-시-this-를-수동으로-지정하기manual-setting-of-this-value-for-a-function-call"><a class="header" href="#함수-호출-시-this-를-수동으로-지정하기manual-setting-of-this-value-for-a-function-call">함수 호출 시 <code>this</code> 를 수동으로 지정하기(Manual setting of this value for a function call)</a></h2>
<p>함수 호출 시에 this 값을 수동적으로 지정할 수 있게 해주는 두 가지 방법이 <code>Function.prototype</code> 에 정의되어 있다(<code>prototype</code> 에 정의되어 있으므로 모든 함수가 이용 가능). 바로 <code>apply</code> 와  <code>call</code> 메서드다.</p>
<pre><code class="language-js">var b = 10;

function a(c) {
  alert(this.b);
  alert(c);
}

a(20); // this === global, this.b == 10, c == 20

a.call({b: 20}, 30); // this === {b: 20}, this.b == 20, c == 30
a.apply({b: 30}, [40]) // this === {b: 30}, this.b == 30, c == 40
</code></pre>
<h4 id="reference"><a class="header" href="#reference">Reference</a></h4>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/">Dmitry Soshnikov  in ECMAScript</a></li>
<li><a href="http://huns.me/development/258">김코딩님이 코딩 잘하고 싶어서 만든 블로그</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ES3/1-Execution_Contexts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../ES3/4-ScopeChain.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ES3/1-Execution_Contexts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../ES3/4-ScopeChain.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
