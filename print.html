<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Javascript Basic &amp; Detail</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="spacer"></li><li><a href="Basic/index.html"><strong aria-hidden="true">2.</strong> Basic</a></li><li><ol class="section"><li><a href="Basic/1-CallStack.html"><strong aria-hidden="true">2.1.</strong> Call Stack</a></li><li><a href="Basic/2-Type.html"><strong aria-hidden="true">2.2.</strong> Type</a></li><li><a href="Basic/3-Function.html"><strong aria-hidden="true">2.3.</strong> Function</a></li><li><a href="Basic/4-Module.html"><strong aria-hidden="true">2.4.</strong> Module</a></li><li><a href="Basic/5-Event_Loop.html"><strong aria-hidden="true">2.5.</strong> Event Loop</a></li><li><a href="Basic/6-Async.html"><strong aria-hidden="true">2.6.</strong> Async</a></li><li><a href="Basic/7-Engine.html"><strong aria-hidden="true">2.7.</strong> Engine</a></li><li><a href="Basic/8-Bitwise_Operator.html"><strong aria-hidden="true">2.8.</strong> Bitwise Operator</a></li><li><a href="Basic/9-DOM.html"><strong aria-hidden="true">2.9.</strong> DOM</a></li><li><a href="Basic/10-Class.html"><strong aria-hidden="true">2.10.</strong> Class</a></li><li><a href="Basic/11-Call-Apply-Bind.html"><strong aria-hidden="true">2.11.</strong> Call, Apply, Bind</a></li><li><a href="Basic/12-Prototype.html"><strong aria-hidden="true">2.12.</strong> Prototype</a></li><li><a href="Basic/13-Object.create_Object.assign.html"><strong aria-hidden="true">2.13.</strong> Object.create, Object.assign</a></li><li><a href="Basic/index.html"><strong aria-hidden="true">2.14.</strong> To be continue</a></li><li class="spacer"></li></ol></li><li><a href="ES3/index.html"><strong aria-hidden="true">3.</strong> ES3 in Detail</a></li><li><ol class="section"><li><a href="ES3/1-Execution_Contexts.html"><strong aria-hidden="true">3.1.</strong> Execution Contexts</a></li><li><a href="ES3/3-This.html"><strong aria-hidden="true">3.2.</strong> This</a></li><li><a href="ES3/4-ScopeChain.html"><strong aria-hidden="true">3.3.</strong> Scope Chain</a></li><li><a href="ES3/5-Function.html"><strong aria-hidden="true">3.4.</strong> Function</a></li><li><a href="ES3/6-Closure.html"><strong aria-hidden="true">3.5.</strong> Closure</a></li><li><a href="ES3/index.html"><strong aria-hidden="true">3.6.</strong> To be continue</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <style>
  header.warning {
    background-color: rgb(242, 222, 222);
    border-bottom-color: rgb(238, 211, 215);
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border-bottom-style: solid;
    border-bottom-width: 0.666667px;
    border-image-outset: 0 0 0 0;
    border-image-repeat: stretch stretch;
    border-image-slice: 100% 100% 100% 100%;
    border-image-source: none;
    border-image-width: 1 1 1 1;
    border-left-color: rgb(238, 211, 215);
    border-left-style: solid;
    border-left-width: 0.666667px;
    border-right-color: rgb(238, 211, 215);
    border-right-style: solid;
    border-right-width: 0.666667px;
    border-top-color: rgb(238, 211, 215);
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    border-top-style: solid;
    border-top-width: 0.666667px;
    color: rgb(185, 74, 72);
    margin-bottom: 0px;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 30px;
    padding-bottom: 8px;
    padding-left: 14px;
    padding-right: 35px;
    padding-top: 8px;
    text-align: center;
  }
</style>


                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Javascript Basic &amp; Detail</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p><sub>Built with <a href="https://github.com/SeonHyungJo/">sNyung</a></sub></p>
<a class="header" href="#basic" id="basic"><h1>Basic</h1></a>
<a class="header" href="#call-stack" id="call-stack"><h1>Call Stack</h1></a>
<a class="header" href="#type" id="type"><h1>Type</h1></a>
<a class="header" href="#function" id="function"><h1>Function</h1></a>
<a class="header" href="#module" id="module"><h1>Module</h1></a>
<a class="header" href="#event-loop" id="event-loop"><h1>Event Loop</h1></a>
<a class="header" href="#async" id="async"><h1>Async</h1></a>
<a class="header" href="#engine" id="engine"><h1>Engine</h1></a>
<a class="header" href="#bitwise-operator" id="bitwise-operator"><h1>Bitwise Operator</h1></a>
<a class="header" href="#dom" id="dom"><h1>DOM</h1></a>
<a class="header" href="#class" id="class"><h1>Class</h1></a>
<a class="header" href="#call-apply-bind" id="call-apply-bind"><h1>Call, Apply, Bind</h1></a>
<a class="header" href="#prototype" id="prototype"><h1>Prototype</h1></a>
<a class="header" href="#objectcreate-objectassign" id="objectcreate-objectassign"><h1>Object.create, Object.assign</h1></a>
<a class="header" href="#basic-1" id="basic-1"><h1>Basic</h1></a>
<a class="header" href="#es3" id="es3"><h1>ES3</h1></a>
<a class="header" href="#es3-execution-contexts" id="es3-execution-contexts"><h1>[ES3] Execution Contexts</h1></a>
<a class="header" href="#도입" id="도입"><h2>도입</h2></a>
<p>오늘은 ECMAScript의 실행 컨텍스트와 이와 관련된 코드 유형에 대해 알아보자.</p>
<a class="header" href="#정의" id="정의"><h2>정의</h2></a>
<p>Control이 ECMAScript 실행 코드로 이동될 때마다, Control은 실행 컨텍스트으로 들어가게 된다.</p>
<blockquote>
<p>실행 컨텍스트(EC)는 ECMA-262 specification(사양)에서 실행 코드의 유형화와 차별화를 위해 사용하는 추상적인 개념이다.</p>
</blockquote>
<p>이러한 표준은 기술적인 구현 관점에서 정확한 EC의 구조와 종류를 정의하지 않았다. 이는 결국 표준을 규현하는 ECMAScript 엔진의 달렸다.</p>
<p>논리적으로, 활성 실행 컨텍스트 집합은 stack으로 형성된다. 이 stack의 맨 아래에는 항상 <em>global context</em>가 있고, 가장 위에는 현재(활성) 실행 컨텍스트가 있다. 다양한 종류의 EC가 드나드는동안 stack이 수정된다.(pulled/poped)</p>
<a class="header" href="#실행-코드의-종류" id="실행-코드의-종류"><h2>실행 코드의 종류</h2></a>
<p>실행 컨텍스트의 추상 개념으로 <em>실행 코드 유형</em>의 개념과 관련있다. 코드 유형에 대해 말하면 특정 순간의 실행 컨텍스트를 의미할 수 있다.</p>
<p>예를 들어, 실행 컨텍스트 stack을 배열로 정의해보자.</p>
<pre><code class="language-js">ECStack = [];
</code></pre>
<p>함수가 재귀적 또는 생성자로 호출되더라도 함수안으로 들어갈 때마다 stack에 push한다. 내장 <code>eval</code> 함수 작업에서도 그렇다.</p>
<a class="header" href="#global-code" id="global-code"><h2>Global code</h2></a>
<p>이 유형의 코드는 <code>Program</code> 수준에서 처리된다. 즉, 로드된 외부 <code>.js</code> 파일 또는 로컬 인라인 코드(<code>&lt;script&gt;&lt;/script&gt;</code> 태그 내부)이다. Global code는 함수 본문에 있는 코드 부분은 포함되어 있지 않다.</p>
<p>초기화(프로그램 시작)시 <code>ECStack</code>은 다음과 같다.</p>
<pre><code class="language-js">ECStack = [
  globalContext
];
</code></pre>
<a class="header" href="#function-code" id="function-code"><h2>Function code</h2></a>
<p>Function code (모든 종류의 함수)안으로 들어가게 되면, <code>ECStack</code>에 새로운 요소가 추가된다. concrete Function의 Code에는 내부 Function Code가 포함되어 있지 않다.</p>
<p>예를 들어, 한 번 재귀적으로 호출하는 함수를 보자.</p>
<pre><code class="language-js">(function foo(flag) {
  if (flag) {
    return;
  }
  foo(true);
})(false);
</code></pre>
<p>그러면 다음 ECStack이 다음과 같이 수정된다.</p>
<pre><code class="language-js">// first activation of foo
ECStack = [
  &lt;foo&gt; functionContext
  globalContext
];
  
// recursive activation of foo
ECStack = [
  &lt;foo&gt; functionContext – recursively 
  &lt;foo&gt; functionContext
  globalContext
];
</code></pre>
<p>함수에서 모든 리턴은 현재 실행 컨텍스트를 종료하고 이에 따라 <code>ECStack</code>은 stack의 자연스러운 구현에 따라 연속적으로 거꾸로 꺼내진다. 해당 코드의 작업이 완료되면, <code>ECStack</code>은 프로그램이 종료될 때까지 <code>globalContext</code>만 가지고 있는다.</p>
<p>Throw 되었지만 catch 되지 않은 예외는 하나 이상의 실행 컨텍스트를 종료할 수 있다.</p>
<pre><code class="language-js">(function foo() {
  (function bar() {
    throw 'Exit from bar and foo contexts';
  })();
})();
</code></pre>
<a class="header" href="#eval-code" id="eval-code"><h2>Eval code</h2></a>
<p><code>eval</code> 코드는 매우 흥미롭다. 이 경우 <em>calling context</em>의 개념, 즉 <code>eval</code> 함수가 호출된 컨텍스트가 있다.</p>
<p>변수 또는 함수 정의와 같이 <code>eval</code>에 의해 수핸된 작업은 <em>calling context</em>에 영향을 준다.</p>
<pre><code class="language-js">// influence global context
eval('var x = 10');
 
(function foo() {
  // and here, variable &quot;y&quot; is
  // created in the local context
  // of &quot;foo&quot; function
  eval('var y = 20');
})();
  
alert(x); // 10
alert(y); // &quot;y&quot; is not defined
</code></pre>
<blockquote>
<p>Note: ES5의 strict-mode에서 <code>eval</code>은 이미 호출 컨텍스트에 영향을 미치지 않지만 대신 로컬 <em>sandbox</em>의 코드를 평가한다.</p>
</blockquote>
<p>위의 예에서는 다음과 같은 <code>ECStack</code> 수정 사항이 있다.</p>
<pre><code class="language-js">ECStack = [
  globalContext
];
  
// eval('var x = 10');
ECStack.push({
  context: evalContext,
  callingContext: globalContext
});
 
// eval exited context
ECStack.pop();
 
// foo funciton call
ECStack.push(&lt;foo&gt; functionContext);
 
// eval('var y = 20');
ECStack.push({
  context: evalContext,
  callingContext: &lt;foo&gt; functionContext
});
 
// return from eval 
ECStack.pop();
 
// return from foo
ECStack.pop();
</code></pre>
<p>즉 아주 캐주얼하고 논리적인 <em>call-stack</em>이다.</p>
<blockquote>
<p>Note: 예전 SpiderMonkey(Firefox)에서 버전 1.7까지는 <code>eval</code> 함수의 두 번째 인수로 전달할 수 있었다. 따라서 컨텍스트가 여전히 존재하면 개인 변수에 영향을 줄 수 있었다.</p>
</blockquote>
<pre><code class="language-js">function foo() {
  var x = 1;
  return function () { alert(x); };
};
 
var bar = foo();
 
bar(); // 1
 
eval('x = 2', bar); // pass context, influence internal var &quot;x&quot;
</code></pre>
<blockquote>
<p>하지만 최신 엔진에서는 보안상의 이유로 수정되어 더 이상 중요하지 않다.</p>
</blockquote>
<hr />
<a class="header" href="#reference" id="reference"><h4>Reference</h4></a>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/">ECMA-262-3 in detail. Chapter 1. Execution Contexts</a></li>
</ul>
<a class="header" href="#es3ecma-262-3-this" id="es3ecma-262-3-this"><h1>[ES3]ECMA-262-3 This</h1></a>
<blockquote>
<p>실행콘텍스트가 선행되어야 합니다.</p>
</blockquote>
<p>이번 주제는 <code>this</code> 키워드다.
<br/></p>
<p>사례에서 보듯이, 이 주제는 상당히 어려워서 종종 다른 실행 콘텍스트의 <code>this</code> 값을 처리할 때 이슈를 만들곤 한다.
<br/></p>
<a class="header" href="#정의-1" id="정의-1"><h2>정의</h2></a>
<p><code>this</code>는 <strong>실행 콘텍스트의 프로퍼티</strong>다.</p>
<pre><code class="language-js">activeExecutionContext = {
  VO: {...},
  this: thisValue // 다른 하나가 더 있다. scope, 총 3개이다.
};
</code></pre>
<p>여기의 <code>VO</code> 는 <strong>변수 객체(Variable object)를 의미</strong> 한다.
<br/></p>
<p><code>this</code> 는 콘텍스트의 실행 코드 타입과 직접적인 관련이 있다.
이 값은 콘텍스트로 진입하는 과정에서 정해지며, 콘텍스트 안의 코드가 실행 중에는 변하지 않는다.
<br/></p>
<p>좀 더 자세하게 들여다보자.
<br/></p>
<p>전역 코드 안의 <code>this(This value in the global code)</code> 이건 정말 단순하다. 전역이니까 당연히 <code>this</code> 는 전역객체 <strong>자신</strong> 이 될 것이다.</p>
<pre><code class="language-js">// 명시적인 전역 객체 프로퍼티 정의
this.a = 10; // global.a = 10
alert(a); // 10

// 규정되지 않은 식별자 할당을 이용한 암묵적 정의
b = 20;
alert(this.b); // 20

// 전역 콘텍스트의 변수 객체는 전역 객체 자신이기 때문에
// 또한 변수 선언을 이용한 암묵적 정의도 가능하다.
var c = 30;
alert(this.c); // 30
</code></pre>
<p>함수 코드 안의 <code>this(This value in the function code)</code> 이제부터가 진짜라고 할 수 있다. 함수타입의 코드의 <code>this</code> 는 함수에 정적으로 바인딩이 되지 않는다는 것이다.
<br/></p>
<p>콘텍스트로 들어갈때 정해지며, 함수코드의 <code>this</code> 는 매번 바뀔 수 있다.
<br/></p>
<p>그러나 코드나 코드가 실행이 되고 <code>this</code> 는 변경이 이루어질수 없다(이 얘기는 아래에서 또 나올 것이다.)
<br/></p>
<p>즉 <code>this</code> 를 재할당하는 것이 불가능 하다는 것이다.</p>
<pre><code class="language-js">var foo = {x: 10};
var bar = {x: 20,test: function () {   
  alert(this === bar); 
  // true   
  alert(this.x); // 20   
  this = foo; // 에러, this 값을 변경할 수 없다.   
  alert(this.x); // 
  // 만약 위에서 에러가 나지 않았다면 20이 아닌 10이 출력될 것이다.
  }
};
// 콘텍스트로 들어올 때 this가 가리키는 대상이 bar 객체로 결정된다.
// 왜 그러한지는 아래에서 자세하게 설명하겠다.
bar.test(); // true, 20
foo.test = bar.test;
// 그러나 여기의 this는 이제 foo를 참조할 것이다.  
// 심지어 같은 함수를 호출하는 데도 말이다.
foo.test(); // false, 10
</code></pre>
<p>그렇다면 어떻게 해야 this가 바뀌는 것일까??
<br/></p>
<p>콘텍스트의 코드를 활성화시킨 <strong>호출자(caller)에 의해</strong> 제공된다.
<br/></p>
<p>즉 함수를 호출한 부모 콘텍스트가 존재한다는 것이다. 어떤 콘텍스트의 this가 참조하는 값을 어려움없이 알아내기를 원한다면 중요한 이 부분을 이해하고 기억해야 한다.
<br/></p>
<p>정확하게 호출 표현식의 형태, <strong>즉 다른 무엇이 아닌 함수를 호출한 방법이 호출된 콘텍스트</strong>의 <code>this</code> 값에 영향을 준다.
<br/></p>
<blockquote>
<p><code>this</code> 값은 함수가 어떻게 정의되었는가에 따라 정해진다. 전역 함수라면 <code>this</code> 는 전역 객체를 값으로 갖게 되고, 객체의 메서드라면 <code>this</code> 는 항상 이 객체를 값으로 갖는다.
<br/></p>
</blockquote>
<p>이건 정말 나도 많이보고 이렇게 생각했다. 그러나 아니다...(많이 당했다 크게 당했다...심지어 보통의 전역 함수도 다른 형태의 호출 표현식으로 활성화되면 <code>this</code> 값이 달라진다.</p>
<pre><code class="language-js">function foo() {
  console.log(this);
}

foo(); // global

console.log(foo === foo.prototype.constructor); // true

foo.prototype.constructor(); // foo.prototype
</code></pre>
<p>위의 의미가 처음에는 무슨 의미인지 몰랐다.
<br/></p>
<p>그러나 <code>foo === foo.prototype.constructor</code> 이 부분을 먼저 보자면 전역함수인 <code>foo</code> 가 <code>foo.prototype.constructor</code> 가 같으므로 둘 다 전역이라고 생각할 수 있다.
<br/></p>
<p>그렇다면 <code>foo.prototype.constructor</code> 를 실행하게 되면?? 당연히 <code>this</code> 는 <code>global</code> 이 되는 것이 맞다는 것이다.
<br/></p>
<p>그런데 실질적인 결과는 다르다!! 이것과 유사하게 어떤 객체의 메서드로 정의된 함수를 호출하는 경우에 있어서도 <code>this</code> 가 달라질 수 있다.</p>
<pre><code class="language-js">var foo = {
  bar: function () {   
    console.log(this);   
    console.log(this === foo);
  }
};

foo.bar(); // foo, true

var exampleFunc = foo.bar;
console.log(exampleFunc === foo.bar); // true

exampleFunc(); // global, false
</code></pre>
<p>이 경우도 똑같다고 생각하면 된다. <code>exampleFunc === foo.bar</code> 의 결과가 같다면 <code>this</code> 는 같은 것이 나올거라 일반적으로 생각을 할 것이다.
<br/></p>
<p>그런데!! 결과를 보게 되면 놀랍다.
<code>global</code> 이 되는 것이다.
<br/></p>
<p>그렇다면 <strong>호출 표현식의 형태</strong>가 어떻게 <code>this</code> 에 영향을 미칠까?
<br/></p>
<p><code>this</code> 가 갖는 값을 결정하는 과정을 완벽하게 이해하기 위해서, 내부 타입 중에 하나인 <strong>레퍼런스 타입(Reference type)</strong> 에 대해서 자세하게 알 필요가 있다.
<br/></p>
<a class="header" href="#레퍼런스-타입" id="레퍼런스-타입"><h2>레퍼런스 타입</h2></a>
<p>레퍼런스 타입은 수도 코드를 이용해서 <code>base</code> (프로퍼티가 속해 있는 객체)와 이 <code>base</code> 안에 있는 <code>propertyName</code> s이라는 2개의 프로퍼티를 갖고 있는 객체로 나타낼 수 있다.
<br/></p>
<pre><code class="language-js">var valueOfReferenceType = {
  base: &lt;base object&gt;,
  propertyName: &lt;property name&gt;
};
</code></pre>
<p>레퍼런스 타입의 값은 오직 아래의 2가지 경우에만 있을 수 있다.내가 볼 때 아래에 2가지 경우가 <code>this</code> 를 이해하는데 핵심이다.</p>
<pre><code>1. 식별자(identifier)를 다룰 때
2. 프로퍼티 접근자(property accessor)를 다룰 때.
</code></pre>
<p>식별자는 알고리즘이 항상 레퍼런스 타입 값(this와 관련해서 중요하다)을 결과로 돌려준다는 것만 명심하자.
<br/></p>
<p><strong>식별자는 변수 이름, 함수 이름, 함수 전달인자의 이름 그리고 전역 객체의 비정규화 프로퍼티의 이름을 뜻한다.</strong>
<br/></p>
<pre><code class="language-js">var foo = 10; // 변수이름
function bar() {} // 함수이름
</code></pre>
<p>중간결과는 아래와 같이 될 것이다.</p>
<pre><code class="language-js">var fooReference = {
  base: global,
  propertyName: 'foo'
};

var barReference = {
  base: global,
  propertyName: 'bar'
};
</code></pre>
<p>레퍼런스 타입 값으로부터 객체가 갖고 있는 실제 값을 얻기 위해 쓰이는 <code>GetValue</code> 메소드가 있는데 이 메소드를 수도 코드로 아래와 같이 나타낼 수 있다.</p>
<pre><code class="language-js">function GetValue(value) {
  if (Type(value) != Reference) {   
    return value;    // 레퍼런스 타입이 아니면 값을 그대로 돌려준다.
  }
  
  var base = GetBase(value);
  
  if (base === null) {   
    throw new ReferenceError;
  }
  
  return base.[[Get]](GetPropertyName(value))
}
</code></pre>
<p>위에서 내부 <code>[[Get]]</code> 메소드는 프로토타입 체인으로부터 상속된 프로퍼티까지 분석해서 <strong>객체 프로퍼티의 실제 값</strong> 을 돌려준다.</p>
<pre><code class="language-js">GetValue(fooReference); // 10
GetValue(barReference); // function object &quot;bar&quot;
</code></pre>
<p><strong>(중요)프로퍼티 접근자는 점 표기법(프로퍼티 이름이 정확한 식별자이고 미리 알 수 있을 때)이나 대괄호 표기법의 2가지 방법으로 표기할 수 있다.</strong></p>
<pre><code class="language-js">foo.bar();
foo['bar']();
</code></pre>
<p>이번에도 중간 계산의 결과로 레퍼런스 타입의 값을 갖게 된다.</p>
<pre><code class="language-js">var fooBarReference = { 
  base: foo, 
  propertyName: 'bar'
};

GetValue(fooBarReference); // function object &quot;bar&quot;
</code></pre>
<p>그렇다면, 레퍼런스 타입의 값과 함수 콘텍스트의 <code>this</code> 값은 어떤 관계일까? <strong>이 부분이 가장 중요하며, 이 글의 메인이다</strong>.
<br/></p>
<p>함수 콘텍스트의 <code>this</code> 값을 결정하는 일반적인 규칙은 다음과 같이 말할 수 있다.
<br/></p>
<p>함수 콘텍스트의 <code>this</code> 값은 <strong>호출자가 제공</strong> 하며 <strong>호출 표현식의 현재 형태에 의해서 그 값이 결정</strong> 된다(함수 호출이 문법적으로 어떻게 이뤄졌는지에 따라서).
<br/></p>
<p>호출 괄호(…)의 왼편에 <strong>레퍼런스 타입의 값이 존재하면</strong>, <code>this</code> 는 레퍼런스 타입의 <code>this</code> 값인 <code>base</code> 객체를 값으로 갖는다.
<br/></p>
<p>다른 모든 경우에는(레퍼런스 타입이 없는 다른 모든 값의 경우), <code>this</code> 값은 항상 <code>null</code> 로 설정된다. 그러나 <code>null</code> 은 <code>this</code> 의 값으로 의미가 없기 때문에 암묵적으로 전역 객체로 변환된다.</p>
<p>예제</p>
<pre><code class="language-js">function foo() {
 return this;
}
foo(); // global
</code></pre>
<p>호출괄호 왼쪽에 레퍼런스 타입 값이 있다.(<code>foo</code> 는 함수이름으로 식별자이다)</p>
<pre><code class="language-js">var fooReference = {
 base: global,
 propertyName: 'foo'
};
</code></pre>
<p>따라서, <code>this</code> 값은 레퍼런스 타입 값의 <code>base</code> 객체인 전역 객체로 설정된다.</p>
<pre><code class="language-js">var foo = {
 bar: function () {
   return this;
 }
};
foo.bar(); // foo
</code></pre>
<p>여기에서 다시 <code>base</code> 가 <code>foo</code> 객체인 레퍼런스 타입의 값을 갖게 되고, 이것은 <code>bar</code> 함수 활성화 시에 <code>this</code> 값으로 이용된다.</p>
<pre><code class="language-js">var fooBarReference = {
 base: foo,
 propertyName: 'bar'
};
</code></pre>
<p>그러나, 또 다른 형태의 호출 표현식으로 함수를 활성화시키면 this 값은 달라진다.</p>
<pre><code class="language-js">var test = foo.bar;
test(); // global
</code></pre>
<p><code>test</code> 가 식별자가 되면서 다른 레퍼런스 타입 값을 만들기 때문에, 이 레퍼런스 타입의 <code>base</code> (전역 객체)가 <code>this</code> 값으로 사용된다.</p>
<pre><code class="language-js">var testReference = {
 base: global,
 propertyName: 'test'
};
</code></pre>
<p>이제는 다른 형태의 호출 표현식으로 활성화된 같은 함수가, 또한 다른 <code>this</code> 값을 갖는지를 정확하게 이야기할 수 있다
=&gt; <strong>레퍼런스 타입의 중간 값이 달라서 일어나는 현상</strong></p>
<pre><code class="language-js">function foo() {
 alert(this);
}
foo(); // 전역이기 때문에

var fooReference = {
 base: global,
 propertyName: 'foo'
};

alert(foo === foo.prototype.constructor); // true

// 호출 표현식의 또 다른 형태
foo.prototype.constructor(); // foo.prototype이기 때문에

var fooPrototypeConstructorReference = {
 base: foo.prototype,
 propertyName: 'constructor'
};
</code></pre>
<p>호출 표현식 형태에 따라 <code>this</code> 값이 동적으로 결정되는 또 다른 에제가 있다.</p>
<pre><code class="language-js">function foo() {
 alert(this.bar);
}

var x = {bar: 10};
var y = {bar: 20};

x.test = foo;
y.test = foo;

x.test(); // 10
y.test(); // 20
</code></pre>
<a class="header" href="#함수-호출과-비-레퍼런스-타입function-call-and-non-reference-type" id="함수-호출과-비-레퍼런스-타입function-call-and-non-reference-type"><h2>함수 호출과 비-레퍼런스 타입(Function call and non-Reference type)</h2></a>
<p>호출 괄호의 왼편에 레퍼런스 타입이 아닌 다른 값이 오는 경우 this값은 자동으로 <code>null</code> 값을 가지게 된다. 그리고 이것을 엔진은 자동으로 전역객체로 출력한다.</p>
<pre><code class="language-js">(function () {
 alert(this); // null =&gt; global
})();
</code></pre>
<p>딱 위의 경우가 좋은 에시이다. 이것은 레퍼런스타입(식별자, 프로퍼티 접근자)가 아니다. 따라서 레퍼런스타입이 존재하지 않는다. 즉 <code>null</code> 이다 그럼으로 전역객체를 출력한다.</p>
<pre><code class="language-js">var foo = {
 bar: function () {
   alert(this);
 }
};

foo.bar(); // Reference, OK =&gt; foo
(foo.bar)(); // Reference, OK =&gt; foo

(foo.bar = foo.bar)(); // global?
(false || foo.bar)(); // global?
(foo.bar, foo.bar)(); // global?
</code></pre>
<p>이 경우가 정말 어렵다. 왜 아래의 <strong>3개의 경우에는 왜 전역객체가 나오는 것일까?</strong>
<br/></p>
<p>즉 아래의 3개는 레퍼런스 타입 값이 <code>null</code>이라는 것이다.
<br/></p>
<p>두번째 경우에는 <strong>그룹핑 연산자</strong>가 레퍼런스 타입의 값으로부터 객체의 실제 값을 얻기 위한 메소드인 <code>GetValue</code> 에 적용되지 않는다. 그래서 그룹핑 연산자가 평가 결과를 반환할 때도 여전히 레퍼런스 타입의 값이 존재 하게 되는데, 이것이 this 값이 다시 <code>base</code> 객체로 설정되는 이유다.
<br/></p>
<p>세번째의 경우는, <strong>그룹핑 연산자와 다르게 할당 연산자는 GetValue 메소드를 호출한다.</strong> 반환의 결과로 <code>this</code> 가 <code>null</code>로 설정되었음을 의미하는 함수 객체(레퍼런스 타입 값은 아닌)가 반환되기 때문에, 이는 결국 전역 객체가 된다.
<br/></p>
<p>네번째와 다섯번째의 경우도 유사하다. <strong>콤마 연산자와 논리적 OR 표현식</strong>은 <code>GetValue</code> 메소드를 호출하고, 따라서 레퍼런스 타입의 값을 잃어버리고 함수 타입의 값을 갖게 되어 <code>this</code> 의 값은 전역 객체로 설정된다.
<br/></p>
<p>레퍼런스 타입과 값이 <code>null</code> 인 <strong>this(Reference type and null this value)</strong> 위에도 말은 했지만 레퍼런스타입의 값이 <strong>null이 되면 this는 전역객체가 된다고 했다.</strong> 이것은 레퍼런스 타입 값의 base 객체가 활성화 객체인 경우와 관련이 있다.</p>
<pre><code class="language-js">function foo() {
 function bar() {
   alert(this); // global
 }
 bar(); // AO.bar()와 같다.
}
</code></pre>
<p><strong>활성화 객체는 항상 this 값으로 null을 반환한다.</strong></p>
<a class="header" href="#예외의-with함수" id="예외의-with함수"><h2>예외의 with함수</h2></a>
<p><code>with</code> 객체가 함수 이름 프로퍼티를 갖는 경우, <code>with</code> 문의 블럭 안에서 함수를 호출 할 때는 예외일 수 있다. <code>with</code> 문은 자신의 스코프 체인의 가장 앞, 즉 활성화 객체 앞에 그 객체를 추가한다.
<br/></p>
<p>따라서 레퍼런스 타입 값을 얻으려 할 때(식별자나 프로퍼티 접근자를 이용해서) 활성화 객체가 아닌 <code>with</code> 문의 객체를 <code>base</code> 객체로 갖게 된다.
<br/></p>
<p>그런데, 이는 <code>with</code> 객체가 스코프 체인에서 더 상위에 있는(전역 객체 또는 활성화 객체) 객체까지 가려버리기 때문에 중첩함수 뿐만 아니라 전역 함수와도 관련이 있다.</p>
<pre><code class="language-js">var x = 10;
with ({
 foo: function () {
   alert(this.x);
 },
 x: 20
}) {
 foo(); // 20
}
// because
var  fooReference = {
 base: __withObject,
 propertyName: 'foo'
};
</code></pre>
<p><code>catch</code> 절의 실제 파라미터인 함수를 호출할 것도 이와 유사하다.
<br/></p>
<p>이 경우에 항상 스코프 체인의 가장 앞, 즉 활성화 객체나 전역 객체 앞에 <code>catch</code> 객체가 추가된다.
<br/></p>
<p>그러나 이 동작은 <code>ECMA-262-3</code> 의 버그로 인정되어 새로운 버전인 <code>ECMA-262-5</code>에서는 수정 된다. <code>ECMA-262-5</code>는 이러한 경우 <code>this</code> 값이 <code>catch</code> <strong>객체가 아닌 전역 객체로 설정된다.</strong></p>
<pre><code class="language-js">try {
 throw function () {
   alert(this);
 };
} catch (e) {
 e(); // __catchObject - ES3, global - ES5에서는 수정
}
// on idea
var eReference = {
 base: __catchObject,
 propertyName: 'e'
};
// 그러나, 이것은 버그이기 때문에
// this는 강제로 전역 객체를 참조하게 된다.
// null =&gt; global
var eReference = {
   base : global,
   propertyName: 'e'
}
</code></pre>
<p><br/></p>
<a class="header" href="#생성자로-호출된-함수-안의-thisthis-value-in-function-called-as-the-constructor" id="생성자로-호출된-함수-안의-thisthis-value-in-function-called-as-the-constructor"><h2>생성자로 호출된 함수 안의 this(This value in function called as the constructor)</h2></a>
<pre><code class="language-js">function A() {
 alert(this); // 새롭게 만들어진 객체, 아래에서 a 객체
 this.x = 10;
}

var a = new A();
alert(a.x); // 10
</code></pre>
<p>이 경우는, <code>new</code> 연산자가 A함수의 내부 [[Construct]] 메소드를 호출하고 차례로, 객체가 만들어진 후에 A와 모두 같은 함수인 내부의 [[Call]] 메소드를 호출하여 <code>this</code> 값으로 새롭게 만들어진 객체를 갖게 된다.
<br/></p>
<a class="header" href="#함수-호출시-this-를-수동으로-지정하기manual-setting-of-this-value-for-a-function-call" id="함수-호출시-this-를-수동으로-지정하기manual-setting-of-this-value-for-a-function-call"><h2>함수 호출시 <code>this</code> 를 수동으로 지정하기(Manual setting of this value for a function call)</h2></a>
<p>함수 호출 시에 this 값을 수동적으로 지정할 수 있게 해주는 두 가지 방법이 <code>Function.prototype</code> 에 정의되어 있다(<code>prototype</code> 에 정의되어 있으므로 모든 함수가 이용 가능). 바로 <code>apply</code> 와  <code>call</code> 메소드다.</p>
<pre><code class="language-js">var b = 10;

function a(c) {
  alert(this.b);
  alert(c);
}

a(20); // this === global, this.b == 10, c == 20

a.call({b: 20}, 30); // this === {b: 20}, this.b == 20, c == 30
a.apply({b: 30}, [40]) // this === {b: 30}, this.b == 30, c == 40
</code></pre>
<p><br/></p>
<a class="header" href="#reference-1" id="reference-1"><h4>Reference</h4></a>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/">Dmitry Soshnikov  in ECMAScript</a></li>
<li><a href="http://huns.me/development/258">김코딩님이 코딩 잘하고 싶어서 만든 블로그</a></li>
</ul>
<a class="header" href="#es3ecma-262-3-scopechain" id="es3ecma-262-3-scopechain"><h1>[ES3]ECMA-262-3 ScopeChain</h1></a>
<a class="header" href="#소개" id="소개"><h2>소개</h2></a>
<ul>
<li>실행 컨텍스트의 데이터(<strong>변수, 함수 선언 그리고 함수의 매개변수</strong>)는 변수 객체의 프로퍼티( <strong>VO</strong> )로 저장된다.
<ul>
<li>깨알 유용한 정보 : <code>Context = VO|AO + this + SC</code></li>
</ul>
</li>
<li>컨텍스트로 <strong>진입</strong> 할 때 매번 초기값을 갖는 변수 객체를 생성하며(선언 + 초기화)(==호이스팅), 코드 <strong>실행</strong> 할 때 값을 갱신(할당)한다.</li>
</ul>
<p>이번에는 스코프 체인에 대해서 정리를 해보자.
<br/></p>
<a class="header" href="#정의-2" id="정의-2"><h2>정의</h2></a>
<p>스코프체인은 대게 중첩 함수와 관련이 있다.</p>
<blockquote>
<p>중첩함수 란 함수안에 함수가 있는 것 &lt;= 당연한 말인 듯하다.</p>
</blockquote>
<p><strong>심지어 부모 함수가 이러한 중첩 함수를 결과 값으로 반환이 가능하다.</strong></p>
<pre><code class="language-js">var x = 10;

function foo() {
 var y = 20;

 function bar() {
   alert(x + y);
 }
 return bar;
}

foo()(); // 30
</code></pre>
<p>소개에서도 나오고 <code>This</code> 편에서도 나왔지만 모든 컨텍스트는 자신의 고유 변수 객체를 가진다.
전역 컨텍스트는 자기 자신을 변수 객체(<code>VO_global</code>)로 가지며, 함수 컨텍스트는 활성화 객체(<code>AO</code>)를 가진다.</p>
<ul>
<li>전역 컨텍스트 = <code>VO + SC + this</code></li>
<li>함수 컨텍스트 = <code>AO + SC + this</code></li>
</ul>
<p>스코프 체인은 내부 컨텍스트가 이용하는 모든(부모) 변수 객체의 <strong>리스트다</strong>.
변수를 검색할 때 이 체인을 이용한다.
<br/></p>
<p>위의 경우에서는 <code>bar</code> 컨텍스트의 스코프 체인은 <code>AO(bar)</code>, <code>AO(foo)</code>, <code>VO(global)</code>를 갖는다.
순서 또한 위와 같이 가진다. 즉 처음에 위치한 것은 자기자신이라는 것이다.
<br/></p>
<blockquote>
<p><code>SC</code> 는 내부 컨텍스트가 이용하는 모든 변수 객체의 리스트</p>
</blockquote>
<p>스코프체인은 실행 컨텍스트와 관련 있으며, <strong>식별자 해석시</strong> 변수 검색에 이용하는 변수 객체의 체인이다.
<br/></p>
<ul>
<li>스코프 체인은 함수를 호출할 때 생성되고</li>
<li>활성화 객체와 함수의 내부 <code>[[scope]]</code> 프로퍼티를 가진다.</li>
</ul>
<p><br/></p>
<a class="header" href="#내부의-모습" id="내부의-모습"><h3>내부의 모습</h3></a>
<pre><code class="language-js">activeExecutionContext = {
   VO: {...}, // or AO
   this: thisValue,
   Scope: [ // 스코프 체인(scope chain)
     // 식별자 검색에 이용할 모든 변수 객체의 리스트
   ]
};
</code></pre>
<p><strong>스코프의 정의</strong></p>
<pre><code class="language-js">Scope = AO + [[scope]]
</code></pre>
<p>예를 들기 위해서 스코프와 <code>[[Scope]]</code> 를 <code>ECMAScript</code> 의 일반 배열로 나타낼 수 있다.</p>
<pre><code class="language-js">var Scope = [VO1, VO2, ..., VOn]; // 스코프 체인
</code></pre>
<pre><code class="language-js">var VO1 = {__parent__: null, ... other data};
var VO2 = {__parent__: VO1, ... other data};
...
</code></pre>
<a class="header" href="#함수-라이프-사이클function-life-cycle" id="함수-라이프-사이클function-life-cycle"><h2>함수 라이프 사이클(Function life cycle)</h2></a>
<p>함수의 라이프 사이클은 <strong>생성 단계</strong>, <strong>활성화 단계(call)</strong> 의 2가지로 나뉜다.</p>
<a class="header" href="#함수-생성" id="함수-생성"><h3>함수 생성</h3></a>
<p>모두가 아시다시피 컨텍스트 단계로 들어갈 때 <strong>변수/활성화 객체(VO/AO)가 함수 선언으로 들어간다.</strong></p>
<pre><code class="language-js">var x = 10;

function foo() {
  var y = 20;
  alert(x + y);
}

foo(); // 30
</code></pre>
<p>함수가 활성화가 되면 함수는 <code>30</code> 을 출력한다.
<br/></p>
<p>여기에서 변수 <code>y</code> 는 함수 <code>foo</code> 에서 정의되어있지만, 변수 <code>x</code> 는 <code>foo</code> 의 컨텍스트에 정의되어 있지않다. 그러므로 <code>foo</code> 의 <code>AO</code> 에 추가가 되지 않는다. 그렇다면 <code>x</code> 는 <code>foo</code> 에 존재하지 않는 것인가?
<br/></p>
<pre><code class="language-js">fooContext.AO = {
  y: undefined // undefined – 컨텍스트 접근시, 20 – 활성화시
};
</code></pre>
<p><code>foo</code> 컨텍스트의 활성화 객체는 <code>y</code> 프로퍼티 만을 가진다.
그렇다면 어떻게 해서 함수 <code>foo</code> 가 변수 <code>x</code> 에 접근할 수 있을까?
<br/></p>
<p><code>[[Scope]]</code> 는 현재 함수 컨텍스트의 상위에 있는 <strong>모든 부모 변수 객체의 계층 체인</strong> 이다. 이 체인은 <strong>함수가 생성될 때 함수에 저장</strong>된다.
<br/></p>
<p>함수를 생성할 때 <code>[[Scope]]</code> 프로퍼티가 함수에 저장되는데, 일단 한 번 저장되고 나면 함수가 사라질 때까지 <strong>정적으로 변하지 않는다</strong> 는 사실을 주목하자. 함수를 결코 <strong>호출할 수 없어도</strong>, 함수 객체는 이미 <code>[[Scope]]</code> 프로퍼티를 가지고 있다.
<br/></p>
<pre><code class="language-js">foo.[[Scope]] = [
  globalContext.VO // === Global
];
</code></pre>
<a class="header" href="#함수-활성화" id="함수-활성화"><h2>함수 활성화</h2></a>
<p>컨텍스트로 진입하고 <code>AO/VO</code> 가 만들어진 후에, 컨텍스트의 <code>scope</code> 프로퍼티는 다음과 같이 정의된다.</p>
<pre><code class="language-js">Scope = AO|VO + [[Scope]]
</code></pre>
<p>여기서 중요한 것은 활성화 객체가 <code>Scope</code> 배열의 첫번째 원소로 제일 앞으로 온다는 것이다.</p>
<pre><code class="language-js">Scope = [AO].concat([[Scope]]);
</code></pre>
<p>식별자 해석은 변수(또는 함수 선언)가 스코프 체인의 어떤 변수 객체에 속하는지를 결정하는 과정이다.
<br/></p>
<p>식별자 해석 과정은 변수의 이름에 해당하는 프로퍼티를 검색하는 과정을 포함하며, 스코프 체인 가장 깊은 곳에 있는 컨텍스트의 변수 객체부터 시작해서 가장 위에 있는 변수 객체까지 연속적으로 검사하는 과정이다.
<br/></p>
<p>그 결과 <strong>현재 컨텍스트의 지역 변수는 부모 컨텍스트에 있는 변수보다 검색 우선 순위를 가지며</strong>, 이름이 같지만 서로 다른 컨텍스트에 존재하는 두 변수의 경우, <strong>더 깊은 컨텍스트에 있는 변수가 우선</strong>한다. 즉 가까운 곳에 위치한 변수가 우선순위가 높다는 것이다.
<br/></p>
<pre><code class="language-js">var x = 10;

function foo() {
 var y = 20;

 function bar() {
   var z = 30;
   alert(x +  y + z);
 }

 bar();
}

foo(); // 60
</code></pre>
<p>전역 컨텍스트의 변수 객체 :</p>
<pre><code class="language-js">globalContext.VO === Global = {
 x: 10
 foo: &lt;reference to function&gt;
};
</code></pre>
<p><code>foo</code> 생성 시점에 <code>foo</code> 의 <code>[[Scope]]</code> 프로퍼티 :</p>
<pre><code class="language-js">foo.[[Scope]] = [
 globalContext.VO
];
</code></pre>
<p><code>foo</code> 함수의 활성화 시점(컨텍스트로 진입하는 단계)에 <code>foo</code> 컨텍스트의 활성화 객체 :</p>
<pre><code class="language-js">fooContext.AO = {
 y: 20,
 bar: &lt;reference to function&gt;
};
</code></pre>
<p><code>foo</code> 컨텍스트의 스코프 체인 :</p>
<pre><code class="language-js">fooContext.Scope = fooContext.AO + foo.[[Scope]] 

fooContext.Scope = [
  fooContext.AO,
  globalContext.VO
];
</code></pre>
<p>중첩된 <code>bar</code> 함수가 생성되는 시점에 <code>bar</code> 함수의 <code>[[Scope]]</code> :</p>
<pre><code class="language-js">bar.[[Scope]] = [
  fooContext.AO,
  globalContext.VO
];
</code></pre>
<p><code>bar</code> 활성화 시점에 <code>bar</code> 컨텍스트의 활성화 객체 :</p>
<pre><code class="language-js">barContext.AO = {
  z: 30
};
</code></pre>
<p><code>bar</code> 컨텍스트의 스코프 체인 :</p>
<pre><code class="language-js">barContext.Scope = barContext.AO + bar.[[Scope]] // i.e.:

barContext.Scope = [
  barContext.AO,
  fooContext.AO,
  globalContext.VO
];
</code></pre>
<a class="header" href="#스코프의-특징scope-features" id="스코프의-특징scope-features"><h2>스코프의 특징(Scope features)</h2></a>
<a class="header" href="#클로저" id="클로저"><h2>클로저</h2></a>
<p><code>ECMAScript</code> 의 클로저는 <code>[[Scope]]</code> 프로퍼티와 직접적으로 관련이 있다. <code>[[Scope]]</code> 는 함수를 생성할 때 함수에 저장되어서, 함수 객체가 사라질 때까지 존재한다. 실제로, 클로저는 정확하게 함수 코드와 <code>[[Scope]]</code> 프로퍼티의 조합이다</p>
<pre><code class="language-js">var x = 10;

function foo() {
    alert(x);
}

(function () {
    var x = 20;
    foo(); // 10, but not 20
})();
</code></pre>
<p>변수 <code>x</code>는 foo 함수의 <code>[[Scope]]</code> 에 있는 것을 알 수 있다. 변수를 검색할 때, 함수 호출 시점의 동적인 체인(이 경우 변수 <code>x</code>의 값은 20이 될 것이다)이 아닌, 함수 생성 순간에 정의된 어휘적인 체인을 이용하였다.</p>
<pre><code class="language-js">function foo() {
  var x = 10;
  var y = 20;

  return function () {
    alert([x, y]);
  };
}

var x = 30;
var bar = foo(); // 익명 함수를 반환한다.

bar(); // [10, 20]
</code></pre>
<p>위이 예제에서도 역시 식별자 해석에 함수 생성 시점에 정의된 어휘적 스코프 체인을 이용하였다. 변수 <code>x</code>를 30이 아닌 10으로 해석했다. 게다가, 이 예제는 함수의 <code>[[Scope]]</code> (함수 <code>foo</code>가 반환한 익명 함수의 경우에)가 심지어 생성된 함수의 컨텍스트가 이미 종료되고 난 이후에도 존재하고 있음을 명확하게 보여준다.
<br/></p>
<a class="header" href="#function-생성자로-생성한-함수의-scope" id="function-생성자로-생성한-함수의-scope"><h3>Function 생성자로 생성한 함수의 <code>[[Scope]]</code></h3></a>
<p>위의 예제에서 함수 생성시에 [[Scope]] 프로퍼티를 가져오고 이 프로퍼티를 통해서 모든 부모 컨텍스트의 변수에 접근한다는 것을 보았다. 그러나, 이 규칙에는 한가지 중요한 예외가 있는데, Function 생성자를 이용해서 함수를 생성하는 경우는 다르다</p>
<pre><code class="language-js">var x = 10;

function foo() {
  var y = 20;

  function barFD() { // FunctionDeclaration
    alert(x);
    alert(y);
  }

  var barFE = function () { // FunctionExpression
    alert(x);
    alert(y);
  };

  var barFn = Function('alert(x); alert(y);');
  barFD(); // 10, 20
  barFE(); // 10, 20
  barFn(); // 10, &quot;y&quot; is not defined
}

foo();
</code></pre>
<p>위에 보이듯이 생성자로 만든 함수는 <code>Scope</code>가 다르다. 그러나 <code>y</code> 에는 접근을 한다 이것은 <code>[[Scope]]</code> 로 <code>global</code>은 가진다는 것이다.</p>
<a class="header" href="#2차원-스코프-체인-검색" id="2차원-스코프-체인-검색"><h3>2차원 스코프 체인 검색</h3></a>
<p>스코프 체인 검색의 중요한 포인트는 <code>ECMAScript</code> 의 프로토타입적인 성격 때문에 변수 객체의 프토토타입 또한 고려해야 한다는 점이다. 객체 내에서 직접적으로 프로퍼티를 찾지 못한다면, <strong>프로토타입 체인까지 검색을 수행</strong> 한다. 즉, 일종의 2차원 체인 검색인 셈이다. <strong>(1) 스코프 체인 연결, (2) 그리고 깊은 프로토타입 체인 연결에 있는 모든 스코프 체인 연결을 검색</strong> 한다.</p>
<pre><code class="language-js">function foo() {
  alert(x);
}

Object.prototype.x = 10;
foo(); // 10
</code></pre>
<p>쉽게 말하면 역시 <code>scope</code> 를 검색했는데 없다 그러면 <code>protptype chain</code> 까지 검색을 한다는 것이다. 그래서 2차원이다.
<br/></p>
<a class="header" href="#전역-컨텍스트와-eval-컨텍스트의-스코프-체인" id="전역-컨텍스트와-eval-컨텍스트의-스코프-체인"><h3>전역 컨텍스트와 <code>eval</code> 컨텍스트의 스코프 체인</h3></a>
<p>전역 컨텍스트의 스코프 체인은 오직 전역 객체만을 갖는다. 그리고 <code>eval</code> 코드의 컨텍스트는 호출 컨텍스트와 같은 스코프 체인을 갖는다.</p>
<p><strong>무조건 글로벌이라고 생각하면 된다.</strong></p>
<pre><code class="language-js">globalContext.Scope = [
    Global
];
evalContext.Scope === callingContext.Scope;
</code></pre>
<p><br/></p>
<a class="header" href="#코드-실행-중-스코프-체인에-영향을-미치기" id="코드-실행-중-스코프-체인에-영향을-미치기"><h3>코드 실행 중 스코프 체인에 영향을 미치기</h3></a>
<p><code>ECMAScript</code> 에는 코드 실행 런타임에 스코프 체인을 변경할 수 있는 두 가지 구문이 있다.
<br/></p>
<p><code>with</code>문과 <code>catch</code>절이다.
<br/></p>
<p>둘 다 이들 구문 내에 나타나는 식별자를 찾기 위한 객체를 <strong>스코프 체인의 가장 앞에 추가한다.</strong> 이 중에 하나를 코드에 적용하면, 스코프 체인은 아래와 같이 변경된다.</p>
<pre><code class="language-js">Scope = withObject|catchObject + AO|VO + [[Scope]]
</code></pre>
<p><code>with</code> 문의 경우에는 파라미터로 넘겨 받은 객체를 추가한다(그 결과, 이 객체의 프로퍼티에 접두사를 붙이지 않고 접근할 수 있다)</p>
<pre><code class="language-js">var foo = {x: 10, y: 20};

with (foo) {
  alert(x); // 10
  alert(y); // 20
}
</code></pre>
<pre><code class="language-js">Scope = foo + AO|VO + [[Scope]]
</code></pre>
<pre><code class="language-js">var x = 10, y = 10;

with ({x: 20}) {
  var x = 30, y = 30;

  alert(x); // 30
  alert(y); // 30
}

alert(x); // 10
alert(y); // 30
</code></pre>
<p><strong>중요</strong></p>
<ol>
<li><code>x = 10, y = 10</code></li>
<li>객체 { <code>x : 20</code> }을 스코프 체인의 앞에 추가한다.</li>
<li>컨텍스트 진입 단계에서 모든 변수를 해석하고 추가했기 때문에 <code>with</code> 내에서 <code>var</code> 구문을 만났을 때 아무 것도 만들지 않는다.</li>
<li>오직 <code>x</code> 의 값을 수정하는데, 정확하게는 두번째 단계에서 스코프 체인의 앞에 추가된 객체 내에서 해석되는 <code>x</code>를 말한다. 20이었던 <code>x</code> 의 값이 10이 된다.</li>
<li>또한 위의 변수 객체 내에서 해석되는 <code>y</code>도 변경한다. 결과적으로 10이었던 <code>y</code>의 값이 30이 된다.</li>
<li>다음으로 <code>with</code> 문이 종료된 후에, 스페셜 객체는 스코프 체인에서 제거된다( <code>x</code> 의 값이 변경되고, 30 또한 객체에서 제거된다). 즉, 스코프 체인 구조가 <code>with</code> 문에 의해서 확장되기 이전 상태로 돌아온다.</li>
<li>마지막에 있는 두 번의 <code>alert</code> 호출을 통해서 알 수 있듯이, 현재 변수 객체 내에 있는 <code>x</code>의 값은 같은 상태로 남아있고, <code>y</code>의 값은 <code>with</code> 문 내에서 변경한 상태 그대로 30이다.</li>
</ol>
<p><code>catch</code> 절 또한 <code>exception</code> 파라미터에 접근하기 위해서 <code>exception</code> 파라미터의 이름을 유일한 프로퍼티로 갖는 중간 스코프 객체를 만들며, 이 객체를 스코프 체인의 앞에 추가한다. 개략적으로 아래와 같이 나타낼 수 있다.</p>
<pre><code class="language-js">try {
  ...
} catch (ex) {
  alert(ex);
}
</code></pre>
<pre><code class="language-js">var catchObject = {
  ex: &lt;exception object&gt;
}
Scope = catchObject + AO|VO + [[Scope]]
</code></pre>
<p><code>catch</code>절 내의 작업이 종료된 후에, 스코프 체인은 이전 상태로 돌아온다.</p>
<hr />
<a class="header" href="#reference-2" id="reference-2"><h4>Reference</h4></a>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/">scope-chain</a></li>
</ul>
<a class="header" href="#es3ecma-262-3-function" id="es3ecma-262-3-function"><h1>[ES3]ECMA-262-3 Function</h1></a>
<a class="header" href="#도입-1" id="도입-1"><h2>도입</h2></a>
<p>함수가 컨텍스트의 변수 객체(VO)에 어떠한 영향을 미치며, 각 함수의 스코프 체인에는 무엇이 들어가는지도 알아보자!!!</p>
<pre><code class="language-js">var foo = function () {...};

function foo() {...}

(function () {...})();
</code></pre>
<p>위와 같이 함수의 경우는 3가지가 있다.
<strong>선언식, 표현식, 즉시실행</strong></p>
<p>이 3가지의 차이점과 특징은 무엇인가에 대해서 자세히 알아볼 필요가 있다.
<br/></p>
<a class="header" href="#함수의-종류" id="함수의-종류"><h2>함수의 종류</h2></a>
<p><code>ECMAScript</code> 에는 세가지 종류의 함수가 있고, 각각의 고유한 특징을 갖는다.
<br/></p>
<a class="header" href="#함수-선언식" id="함수-선언식"><h3>함수 선언식</h3></a>
<p>함수 선언식(줄여서 FD)은 다음과 같은 특징을 갖는다.</p>
<ul>
<li>반드시 이름을 가진다.</li>
<li>소스 코드 위치에 자리한다. 프로그램 레벨이나 다른 함수의 몸체안에 직접 위치한다.</li>
<li>컨텍스트 <strong>진입 시점에 생성</strong> 한다.</li>
<li>변수 객체에 영향을 준다.</li>
</ul>
<pre><code class="language-js">function exampleFunc() {...}
</code></pre>
<p>가장 중요한 특징은 <strong>변수 객체에 영향을 미친다는 것이다.</strong>
이 함수는 컨텍스트의 변수 객체에 들어간다.</p>
<pre><code class="language-js">foo(); // 작동함

function foo() {
    alert('foo');
} 
</code></pre>
<p>위의 소스는 그렇다면 <code>Global</code> 의 <code>VO</code> 에 들어가 있을 것이다.(흔히 호이스팅이라 불리는 것)
<br/></p>
<p>소스 코드 내에 함수를 정의하는 위치 또한 중요하다.</p>
<pre><code class="language-js">// 함수를 다음 2가지 방법으로 선언할 수 있다.
// 1) 전역 컨텍스트에 직접.
function globalFD() {

    // 2) 또는 다른 함수의 몸체 내에서 선언.
    function innerFD() {}
}
</code></pre>
<p>함수를 선언할 수 있는 위치는 결국 두 군데가 있는 것이다.
<br/></p>
<a class="header" href="#함수-표현식" id="함수-표현식"><h3>함수 표현식</h3></a>
<p>함수 표현식(줄여서 FE)은 다음과 같은 함수다.</p>
<ul>
<li><strong>표현식 위치</strong>에만 정의할 수 있다.</li>
<li>선택적으로 이름을 가질 수 있다.(없을 수도 있다.)</li>
<li>함수 표현은 변수 객체에 영향을 주지 않는다.</li>
<li><strong>코드 실행 시점에 생성</strong> 한다.</li>
</ul>
<pre><code class="language-js">var foo = function () {...};
</code></pre>
<p>위의 경우는 익명함수 표현식을 <code>foo</code>변수에 할당하는 것이다.
할당이 끝나면 <code>foo</code> 를 호출할 수 있다. 선택적으로 이름을 줄 수 있다.</p>
<pre><code class="language-js">var foo = function _foo() {...};
</code></pre>
<p>여기에서 주목해야 할 것은 함수 내부에서 <code>_foo</code> 라는 이름을 사용할 수 있을 뿐만 아니라(외부는 사용불가), FE의 바깥에서도 식별자 <code>foo</code>에 접근할 수 있다는 사실이다.
<br/></p>
<p><code>FE</code>를 식별자에 할당하면 <code>FD</code>와 구분하기 어려워진다. 하지만 <code>FE</code>가 <strong>항상 표현식에 위치</strong> 한다는 사실을 알고 있다면, 둘을 쉽게 구분할 수 있다.
<br/></p>
<p>다음 예제에는 다양한 <code>ECMAScript</code> 표현식이 나와있는데, 모든 함수는 함수 표현식이다.</p>
<pre><code class="language-js">// 괄호(그룹화 연산자) 안에서는 표현식이 된다.
(function foo() {});

// 배열 리터럴 안에 있을 경우에도 표현식이다.
[function bar() {}];

// 콤마 또한 표현식으로 처리한다.
1, function baz() {};
</code></pre>
<p>위의 경우의 표현식들은, 표현식 위치에서 함수를 사용하고 변수 객체를 오염시키지 않으려면 필요하다.</p>
<pre><code class="language-js">function foo(callback) {
    callback();
}

foo(function bar() {alert('foo.bar');});
foo(function baz() {alert('foo.baz');});
</code></pre>
<p><code>FE</code>를 변수에 할당하면, 함수는 메모리에 계속 존재한다. 따라서 나중에 변수명으로 접근할 수 있다(알고 있듯이 변수가 변수 객체(VO)에 영향을 주기 때문). &lt;= 다시 말하지만 Global VO에 존재한다는 말이다.</p>
<pre><code class="language-js">var foo = function () {
    alert('foo');
};

foo();
</code></pre>
<p>보조적인 역할을 하는 도우미 데이터를 외부 컨텍스트에 감추기 위해서 유효범위를 캡슐화하는 예제가 있다(FE를 생성 직후 호출).</p>
<pre><code class="language-js">var foo = {};

(function initialize() {
    var x = 10;
    foo.bar = function () {   
        alert(x);
    };
})();

foo.bar(); // 10;

alert(x); // &quot;x&quot; is not defined
</code></pre>
<p>함수 <code>foo.bar</code> ( <code>foo</code> 의 <code>[[Scope]]</code> 프로퍼티에 있는)는 <code>initialize</code> 함수의 내부에 있는 변수 <code>x</code> 에 접근할 수 있다. 그리고 <code>x</code>는 외부에서 직접 접근할 수 없다.
<br/></p>
<p>많은 라이브러리가 <code>private</code> 데이터를 만들어서 보조 개체를 감추는 데 이 전략을 이용한다.
<br/></p>
<p>초기화하는 <code>FE</code> 의 이름을 종종 생략하기도 한다.</p>
<pre><code class="language-js">(function () {
    // 초기화 스코프
})();
</code></pre>
<p>런타임에 조건에 따라 FE를 생성함으로써 <code>VO</code>를 오염시키지 않는 예제도 있다.</p>
<pre><code class="language-js">var foo = 10;
var bar = (
    foo % 2 == 0 ? 
        function () { alert(0); }
        : 
        function () { alert(1); }
);

bar(); // 0
</code></pre>
<a class="header" href="#감싸는-괄호에-대한-질문" id="감싸는-괄호에-대한-질문"><h2>감싸는 괄호에 대한 질문</h2></a>
<p>이 부분은 개발을 오래한 것은 아니지만 1년동안 왜 괄호로 함수를 감싸야 선언과 동시에 호출할 수 있지 라는 생각을 했었다.
<br/></p>
<p><strong>그 답은 바로 표현식 구문이 가지는 제약 때문이었다.</strong>
<br/></p>
<p>표준에 따라서, 표현식 구문은 여는 중괄호, <code>{</code> 로 시작할 수 없다. 블럭과 구분할 수 없기 때문이다. 그리고 함수 선언과 구분하기 힘들기 때문에 함수 키워드로 시작해서도 안 된다.
<br/></p>
<p>다시 말해서, 즉시 실행 함수(function 키워드로 시작하는)를 만들기 위해서 아래와 같이 함수 선언식을 작성했다면,</p>
<pre><code class="language-js">function () {...}();// 또는 아래와 같이 이름이 있는.
function foo() {...}();
</code></pre>
<p>두 경우 모두 파서가 해석 에러를 보고할 것이다.
<br/></p>
<p>이 에러의 원인은 다양하겠지만, 전역 코드에 이렇게 선언을 하면(즉, 프로그램 레벨에), <code>function</code> 키워드로 시작하기 때문에 파서는 코드를 함수 선언식으로 이해한다.
<br/></p>
<p>첫번째 경우는 함수의 이름이 없기 때문에 <code>SyntaxError</code> 를 보고한다.
<br/></p>
<p>두 번째의 경우는 함수에 이름(<code>foo</code>)이 존재하기 때문에 파서가 정상적인 함수 선언으로 처리한다. 하지만 내부에 표현식이 없는 <strong>그룹화 연산자</strong> 를 사용하고 있음을 알리는 문법 에러가 발생한다. 이 경우에 함수 선언 뒤에 오는 것은 함수 호출을 위한 괄호가 아니라 <strong>그룹화 연산자일 뿐이다.</strong> 만약 코드를 다음과 같이 작성했다면,</p>
<pre><code class="language-js">// &quot;foo&quot;는 함수 선언이다
// 그리고 실행 컨텍스트 진입 시점에 생성한다.
alert(foo); 

// function
function foo(x) {
    alert(x);
}(1); // 이것은 호출이 아니라, 그룹화 연산자다.

foo(10); 
// 10
</code></pre>
<p>함수 선언과 표현식 <code>(1)</code>을 가지고 있는 그룹화 연산자가 있기 때문에 두 구문 모두 아무런 문제가 없다.
위의 예제는 아래의 예제와 같다.</p>
<pre><code class="language-js">// 함수 선언
function foo(x) {
    alert(x);
}
// 표현식이 있는 그룹화 연산자
(1);
// 다른 (function) 표현식을 갖는 또 다른 그룹화 연산자
(function () {});

// 내부에 있는 표현식
(&quot;foo&quot;);
</code></pre>
<p><code>ECMA</code> 스펙상으로 볼 때, 위의 코드는 잘못된 구문이다(표현식 구문은 <code>function</code> 키워드로 시작할 수 없다). 하지만 아래에 나와있는 것처럼, 문법 에러를 제공하는 <code>ECMAScript</code> 구현체는 하나도 없으며 모두 이를 각자 나름의 방식으로 처리한다.
<br/></p>
<p>지금까지 설명한 내용을 가지고, 어떻게 파서에게 함수를 생성과 동시에 실행하고 싶다고 이야기할 수 있을까?
<br/></p>
<p><strong>함수 선언식이 아닌 함수 표현식을 사용하면 된다.</strong>
<br/></p>
<p>표현식을 만드는 가장 간단한 방법은 위에서 이야기 했듯이 <strong>그룹화 연산자를 사용한다.</strong> 그룹화 연산자 안에 표현식을 두면, 파서는 함수 표현식(<code>FE</code>)인 코드를 구분할 수 있으며 이에 따라 모호함도 사라진다. 이러한 함수는 코드 실행 단계 동안에 만들어지고, 함수 실행이 끝난 후에는 사라진다(함수를 참조하고 있는 곳이 없다면).</p>
<pre><code class="language-js">(function foo(x) {
    alert(x);
})(1); // 이건 그룹화 연산자가 아닌 함수 호출이다.
</code></pre>
<p>예제의 마지막에 있는 괄호는 <code>FD</code>의 경우처럼 그룹화 연산자가 아니라 함수 호출 괄호다.
<br/></p>
<p>다음 예제에 나오는 즉시 호출 함수는 괄호로 감쌀 필요가 없다는 것에 주목하자. 이유는 함수가 표현식의 위치에 있어서 파서가 이를 코드 실행 시점에 생성하는 <code>FE</code>로 처리해야 한다는 것을 이미 알고 있기 떄문이다.</p>
<pre><code class="language-js">var foo = {
    bar: function (x) {   
        return x % 2 != 0 ? 'yes' : 'no';
    }(1)
};

alert(foo.bar); // 'yes'
</code></pre>
<p>얼핏보면 <code>foo.bar</code>는 함수가 아니라 문자열처럼 보인다. 여기에 있는 함수는 프로퍼티를 초기화할 때만 사용하는데, 조건 매개변수 값에 따라서 값을 돌려주는 함수를 만들고 바로 실행한다. 따라서, <code>괄호</code> 를 묻는 질문에 완벽한 대답은 다음과 같다.</p>
<p>:star: <strong>제일 중요한 부분</strong> :star:</p>
<blockquote>
<p><strong>그룹화 괄호는 함수가 표현식의 위치에 있지 않을 때 필요하고, 함수를 생성 후 즉시 실행하고 싶은 경우에는 직접 함수를 FE로 변환한다.</strong></p>
</blockquote>
<p>괄호를 감싸는 방법 외에 함수를 FE 타입으로 변경할 수 있는 다른 방법이 있다. 예를 들어,</p>
<pre><code class="language-js">1, function () { 
    alert('익명함수를 호출합니다.');
}();// 또는 이렇게,

!function () { 
    alert('ECMAScript');
}();// 그리고 수동적으로 변경하는 다른 방법들...
</code></pre>
<p>올바른 표현식</p>
<pre><code class="language-js">(function () {})();
(function () {}());
</code></pre>
<a class="header" href="#구현의-확장--function문" id="구현의-확장--function문"><h2>구현의 확장 : Function문</h2></a>
<p>다음에 나오는 예제 코드는 어떤 <code>ECMAScript</code> 구현체도 명세를 따르지 않았음을 보여준다.</p>
<pre><code class="language-js">if (true) { 
    function foo() {   
        alert(0); 
    }
} else { 
    function foo() {   
        alert(1); 
    }
}
    
foo(); // 1 또는 0? 다른 ECMAScript 엔진에서 테스트 해보자.
</code></pre>
<p>표준에 비춰볼 때 이 구조는 문제가 있다. 코드 블럭 안에 함수 선언식(<code>FD</code>)을 둘 수 없기 때문이다(지금은 <code>if</code>와 <code>else</code>가 <code>FD</code>를 가지고 있음). 위에서 이야기 했듯이, <code>FD</code>는 프로그램 레벨이나 다른 함수의 몸체 안에 직접 위치해야 한다.
<br/></p>
<p>코드 블럭은 오직 구문만 가질 수 있기 때문에 위의 예제는 잘못되었다. 블럭 내에 함수는 표현식의 위치에만 나올 수 있으며, 함수를 정의할 때는 여는 중괄호(코드 블럭과 구분할 수 없음)나 함수 키워드로 시작할 수 없다(<code>FD</code>와 구분할 수 없음).
<br/></p>
<p>하지만 표준 문서의 <code>error processing</code> 섹션은 <code>ECMAScript</code> 구현체가 프로그램 구문을 확장할 수 있도록 허용하고 있다. 그리고 블럭 안에 등장하는 함수 처리가 이러한 확장 중에 하나다. 오늘날 존재하는 모든 구현체는 이 경우에 예외를 던지지 않고 각자 고유의 방식으로 처리한다.
<br/></p>
<p>위 예제의 <code>if-else</code> 분기문은 두 함수 중 어떤 것을 정의할지 선택할 수 있다고 가정한다. 이 결정은 런타임에 이루어지기 때문에, 함수 표현식(<code>FE</code>)을 사용해야 한다. 하지만 대부분의 구현체는 단순하게 컨텍스트 진입 시점에 두 개의 함수 선언식(<code>FD</code>)을 모두 생성한다. 두 함수 모두 같은 이름을 사용하기 때문에, 마지막에 선언한 함수만 호출할 수 있다. 이런 이유로 이 예제를 실행하면 <code>else</code> 로 코드 제어가 이동할 수 없음에도 불구하고 <code>foo</code> 함수는 1을 출력한다.
<br/></p>
<a class="header" href="#기명함수-표현식의-특징named-function-expression-nfe" id="기명함수-표현식의-특징named-function-expression-nfe"><h2>기명함수 표현식의 특징(Named Function Expression, NFE)</h2></a>
<p>이름을 갖는 <code>FE</code>(기명 함수 표현식, 줄여서 NFE)는 중요한 특징 하나를 가지고 있다.<br />
<br/></p>
<p>함수 표현식을 정의할 때 이야기 했던 것처럼</p>
<ul>
<li>함수 표현식은 컨텍스트의 변수 객체에 영향을 주지 않는다</li>
<li>하지만 FE는 이름으로 자기 자신을 재귀 호출할 수 있다.</li>
</ul>
<pre><code class="language-js">(function foo(bar) {
 if (bar) {
   return;
 }
 foo(true); // &quot;foo&quot; 이름을 이용할 수 있다.
})();
// 하지만 외부에서는 &quot;foo&quot;를 이용할 수 없다.  
foo(); // &quot;foo&quot; is not defined
</code></pre>
<p><code>foo</code> 를 어디에 보관하는 걸까? <code>foo</code>의 활성화 객체 안도 아니다. <code>foo</code> 함수 내부에서 <code>foo</code>라는 이름을 정의한 적이 없다. 그렇다면 <code>foo</code> 를 생성하는 컨텍스트의 변수객체 안도 역시 아니다. <code>FE</code>는 <code>VO</code>에 영향을 주지 않는다는 사실을 외부에서 <code>foo</code> 를 호출하면서 확인했다.  그렇다면 어디일까?
<br/></p>
<p>코드 실행 시점에 인터프리터가 기명 함수 표현식(<code>NFE</code>)을 만나면. 함수 표현식을 만들기 전에 <strong>보조 특수 객체(auxiliary specilal object)</strong> 를 만들고 스코프 체인의 <strong>가장 앞에 이 특수 객체를 추가</strong> 한다. 그런 다음에  함수 표현식을 만드는데, 이 때 함수에 <code>[[Scope]]</code> 프로퍼티(Scope chain에서 배웠듯이)가 생긴다. 여기에는 함수를 생성하는 컨텍스트의 스코프 체인이 들어있다(즉, <code>[[Scope]]</code> 안에 특수 객체가 위치한다). 다음으로, 기명 함수 표현식을 특수 객체에 고유 프로퍼티로 추가한다. 이 프로퍼티의 값은 함수 표현식을 참조한다. 그리고 마지막으로 부모의 스코프 체인에서 특수 객체를 제거한다.</p>
<pre><code class="language-js">specialObject = {};

Scope = specialObject + Scope;

foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}

delete Scope[0]; // 스코프 체인의 가장 앞에 있는 specialObject를 삭제한다.
</code></pre>
<p>따라서, 외부에서는 이 함수의 이름을 사용할 수 없다. 함수의 <code>[[Scope]]</code> 안에 특수 객체가 저장되어 있기 때문에, 내부에서는 이 함수의 이름을 사용할 수 있다.
<br/></p>
<a class="header" href="#마무리" id="마무리"><h2>마무리</h2></a>
<p>생각보다 내용이 많아졌다. 나도 선언식, 표현식을 비교하면서 보여주는 블로그들은 많이 봤지만 정확히 왜 그렇게 되고 즉시실행은 왜 저렇게 될 수 밖에 없는 것인가에 대해서 정리를 해보았다. 자꾸자꾸 보면서 쉬운말로 고쳐봐야겠다.</p>
<hr />
<a class="header" href="#reference-3" id="reference-3"><h4>Reference</h4></a>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/">chapter-5-functions</a></li>
</ul>
<a class="header" href="#es3ecma-262-3-closure" id="es3ecma-262-3-closure"><h1>[ES3]ECMA-262-3 Closure</h1></a>
<p>프로그래밍 패터다임중에 하나로 함수형 프로그래밍이 있다.
<br/></p>
<p>흔히 함수형 언어에서 함수는 데이터다.
<br/></p>
<p>초기 <code>js</code>가 만들어질 때 함수형의 영향을 어느정도 받았다고 한다. 그래서 함수형과 비슷한점이 존재한다.
<br/></p>
<p>즉 함수를 변수에 할당할 수 있고, 다른 함수에 인자로 전달할 수 있으며, 함수의 결과로 반환할 수 있다.
<br/></p>
<a class="header" href="#정의-3" id="정의-3"><h2>정의</h2></a>
<blockquote>
<p>함수 전달인자(Funarg)는 값이 함수인 전달인자다.
<br/></p>
</blockquote>
<pre><code class="language-js">function exampleFunc(funArg) {
    funArg();
}

// 인자로 함수를 넘기고 있음
exampleFunc(function () {
    alert('funArg');
});
</code></pre>
<p>전달인자로 다른 함수를 받는 함수를 <strong>고차함수</strong>(<code>HOF</code>, <code>High Order Function</code>)라고 한다.
<br/></p>
<p>리액트를 하다보면 <code>HOF</code>로 구현을 하는 방법론이 나온다. 그 이야기의 시작은 여기라고 생각한다.
<br/></p>
<p>고차함수(<code>HOF, High Order Function</code>)는 기능적, 수학적으로 연산자로 볼 수 있다.
<br/></p>
<p>위 예제의 <code>exampleFunc</code> 함수는 <strong>고차 함수</strong> 이다.
함수를 전달인자로 넘길 수 있을 뿐만 아니라, 다른 함수의 결과 값으로 함수를 반환할 수도 있다.</p>
<pre><code class="language-js">(function functionValued() {
  return function () {
    alert('returned function is called');
  };
})()();// 함수로 반환한 것을 실행시키고 있다.
</code></pre>
<p>함수를 일반적인 데이터로 취급을 하고 있다.
<br/></p>
<p>함수를 전달하고 함수를 전달자로 받을수 있으며, 함수 값을 반환할 수 있는 함수를 일급객체라 한다.
<br/></p>
<a class="header" href="#일급객체first-class" id="일급객체first-class"><h2>일급객체(First Class)</h2></a>
<p><code>ECMAScript</code> 의 모든 함수는 <strong>일급 객체</strong>다. 자기 자신을 전달인자로 받는 함수를 <strong>자기 응용 함수</strong>라고 부른다..</p>
<pre><code class="language-js">(function selfApplicative(funArg) {

  if (funArg &amp;&amp; funArg === selfApplicative) {
    alert('self-applicative');
    return;
  }

  // 자기 자신을 반환한다.
  // 전에도 말했지만 자신안에서 자신을 부를 수 있다.
  selfApplicative(selfApplicative);
})();
</code></pre>
<p>자기 자신을 반환하는 함수를 <strong>자기 복제 함수</strong>라고 한다. 어느곳에서는 <strong>자가 증식</strong>이라고 말하기도 한다고 한다.</p>
<pre><code class="language-js">(function selfReplicative() {
    return selfReplicative;
})();
</code></pre>
<p>자기 복제 함수를 호출할 때는 인자로 콜렉션 전체가 아닌 각각의 <strong>원소를 하나씩 전달한다.</strong>
<br/></p>
<pre><code class="language-js">// 콜렉션 자체를 매개변수로 받아서 처리하는 함수
function registerModes(modes) {
    // 인자로 전달받은 배열 modes를 순회하면서 각각의 모드를 등록한다.
    modes.forEach(registerMode, modes);
}

// 사용법
registerModes(['roster', 'accounts', 'groups']);

// 자기 복제 함수
function modes(mode) {
  registerMode(mode); // 하나의 모드를 등록한다.
  return modes; // 함수 자신을 반환한다.
}
// 사용법: 인자로 콜렉션 전체가 아닌 각각의 원소를 하나씩 전달한다.
modes
  ('roster')
  ('accounts')
  ('groups')
</code></pre>
<p>이렇게 함수를 호출할 수 있지만, 콜렉션 전체를 전달하는 방식이 더 효율적이고 직관적일 수 있다.
<br/></p>
<p>물론 함수 실행 시점에 전달인자로 넘기는 함수의 지역 변수에 접근할 수 있다. 콘텍스트에 진입할 때마다 콘텍스트 내부의 데이터 보관용 변수 객체를 만들기 때문이다.
<br/></p>
<pre><code class="language-js">function testFn(funArg) {
    // funarg 실행 시점에,
    // 지역 변수 &quot;localVar&quot;를 이용할 수 있다.
    funArg(10); // 20
    funArg(20); // 30
}

testFn(function (arg) {
    var localVar = 10;

    alert(arg + localVar);
});
</code></pre>
<p>하지만 <code>Chapter 4. Scope Chain.</code> 에서 봤듯이, <code>ECMAScript</code> 의 함수는 부모 함수에 속해 <strong>부모 콘텍스트의 변수</strong>를 사용할 수 있다.
<br/></p>
<p>이유는 당연히 <code>SC</code>에 의해서지 !!!
<br/></p>
<p>이러한 특징으로 인해서 <strong>함수 전달인자 문제(funarg problem)</strong> 가 발생하게 된다.
<br/></p>
<a class="header" href="#함수-전달인자-문제funarg-problem" id="함수-전달인자-문제funarg-problem"><h2>함수 전달인자 문제(Funarg problem)</h2></a>
<p><code>Stack</code> 지향 프로그래밍 언어는 함수를 호출할 때마다 함수의 지역 변수와 전달인자를 <code>Stack</code>에 넣는다. 그리고 함수를 종료할 때 <code>Stack</code>에서 변수를 제거한다.
<br/></p>
<p>이 모델을 적용하면 함수를 값(예를 들어, 부모 함수가 반환하는 값으로서의 함수)으로 사용하기 어렵다. – <code>Stack</code>에서 제거되면 사라지기 때문 -. 대게 함수가 자유 변수를 사용할 때 이런 문제가 발생한다.
<br/></p>
<p>자유 변수는 함수가 사용하는 변수 중, 파라미터와 함수의 지역 변수를 제외한 변수를 말한다.
<br/></p>
<pre><code class="language-js">function testFn() {
 var localVar = 10;

 function innerFn(innerParam) {
   alert(innerParam + localVar);
 }
 return innerFn;
}
var someFn = testFn();
someFn(20); // 30
</code></pre>
<p>이 예제의 <code>localVar</code>는 <code>innerFn</code> 함수가 사용하는 자유 변수다. <code>Stack</code> 지향 모델이라고 가정해보면
<br/></p>
<p><code>testFn</code> 함수를 종료하면서 모든 지역 변수를 스택에서 제거할 것이고, 때문에 외부에서 <code>innerFn</code> 함수를 실행하려고 할 때(즉 <code>someFn</code>을 사용하려고 하면 <code>localvar</code>는 이미 사라졌으므로) 에러가 발생할 것이다.
<br/></p>
<p>또한 위의 예처럼 <code>innerFn</code>함수를 반환하는 것이 아예 불가능하다. <code>innerFn</code> 함수가 <code>testFn</code>의 지역에 있기 때문에 <code>testFn</code> 함수가 종료되면서 <code>innerFn</code> 함수도 사라진다는 것이다.
<br/></p>
<p>동적 스코프를 이용하는 시스템에서 함수를 전달인자로 넘길 때 함수 객체가 갖고 있는 다른 문제가 일어난다.
<br/></p>
<pre><code class="language-js">var z = 10;

function foo() {
 alert(z);
}

foo(); // 10 - 정적 스코프와 동적 스코프를 둘다 사용

(function () {
 var z = 20;
 foo(); // 10 – 정적 스코프, 20 – 동적 스코프
})();

// 전달인자로 foo를 넘기는 것과 같다.
(function (funArg) {
 var z = 30;
 funArg(); // 10 – 정적 스코프, 30 – 동적 스코프
})(foo);
</code></pre>
<p>동적 스코프인 경우에는 동적(활동적) 스택을 이용해 변수를 처리한다. 결국 함수를 생성할 때 함수에 저장한 정적(어휘적) 스코프 체인이 아닌, 현재 실행중인 함수의 동적 스코프 체인에서 자유 변수를 찾는다. 이는 모호한 상황을 만든다.
<br/></p>
<p>예를 들어 지역 변수를 스택에서 제거하는 이전 예제와는 달리  <code>z</code>가 계속해서 살아있는 경우, 콘텍스트의 <code>z</code>를 사용해야할지 아니면 스코프의 <code>z</code>를 사용해야할지 알 수 없다.
<br/></p>
<p>지금까지 함수가 함수를 값으로 반환하거나(<code>upward funarg</code>), 함수를 다른 함수에 전달인자로 전달할 때(<code>downward funarg</code>) 생기는 2가지 유형의 함수 전달인자 문제(<code>funarg problem</code>)를 알아봤다.
<br/></p>
<p>클로저는 이러한 문제(및 서브타입)를 해결하기 위해 나온 개념이다.
<br/></p>
<a class="header" href="#클로저closure" id="클로저closure"><h2>클로저(Closure)</h2></a>
<blockquote>
<p>클로저는 코드 블럭과 이 코드 블럭을 생성한 콘텍스트가 갖고 있는 데이터의 조합이다.</p>
</blockquote>
<pre><code class="language-js">var x = 20;

function foo() {
 alert(x); // 자유 변수 &quot;x&quot; == 20
}
// foo의 클로저
fooClosure = {
 call: foo // 함수를 참조
 lexicalEnvironment: {x: 20} // 자유 변수 검색을 위한 콘텍스트
};
</code></pre>
<p>위의 예제의 <code>fooClosure</code>는 물론 의사 코드다. <code>ECMAScript</code> 코드라면 <code>foo</code> 함수는 자신을 생성한 콘텍스트의 스코프 체인을 내부 속성으로 가질 것이다.
<br/></p>
<p>종종 어휘적이라는 단어를 생략하기도 하지만, 위 예제의 경우 클로저가 자기 부모의 변수를 소스 코드 내의 어휘적 위치에서 저장한다는 사실에 관심을 집중하자.<br />
<br/></p>
<p>다음에 함수를 실행하면 저장한 콘텍스트 내에서 자유 변수를 검색한다. 위의 예제를 통해 <code>ECMAScript</code>에서는 변수 <code>z</code>가 항상 <code>10</code>인 것을 알 수 있다.
<br/></p>
<p>위에서 클로저를 정의할 때  코드 블록이라는 일반화 한 개념을 사용했지만, 보통 함수라는 용어를 사용한다.
<br/></p>
<p>하지만 오로지 함수만 클로저와 관련있는 것은 아니다.
<br/></p>
<p>구현에 대해서 이야기를 해보자면, 콘텍스트가 종료된 후에도 지역 변수를 보존하고 싶다면 스택 기반의 아키텍처는 더이상 적합하지 않다. 따라서 이 경우에는 <strong>부모 콘텍스트의 데이터를 가비지 콜렉터(<code>GC</code>)와 참조 카운팅을 이용하는 동적 메모리 할당 방식으로 저장해야 한다(힙 기반 구현)</strong>. 이 방식은 스택 기반 보다 느리다. 하지만 함수 안에서 자유 변수를 사용할지 판단하고 이 결정에 따라 스택이나 힙에 데이터를 배치하는 과정을 스크립트 엔진이 해석 시점에 최적화 할 수 있다.
<br/></p>
<a class="header" href="#ecmascript의-클로저-구현ecmascript-closures-implementation" id="ecmascript의-클로저-구현ecmascript-closures-implementation"><h2>ECMAScript의 클로저 구현(ECMAScript closures implementation)</h2></a>
<p>앞에서 이론적인 이야기를 하면서 마지막에 <code>ECMAScript</code>의 클로저를 언급했다. <code>ECMAScript</code>는 오직 정적(어휘적) 스코프만 사용한다는 사실을 명심하자(Perl 같은 일부 언어는 변수를 정적, 동적 스코프 두 가지 방식으로 선언할 수 있음).
<br/></p>
<pre><code class="language-js">var x = 10;

function foo() {
 alert(x);
}

(function (funArg) {
 var x = 20;
 // funArg는 변수 x를 자신이 선언된 어휘적 콘텍스트에
 // 정적으로 저장한다.
 // 따라서,
 funArg(); // 10, but not 20
})(foo);
</code></pre>
<p>기술적으로, 부모 콘텍스트의 변수는 함수 내부의 <code>[[Scope]]</code> 프로퍼티에 저장된다. <code>Chapter 4</code>에서 이야기했던 <code>[[Scope]]</code>와 스코프 체인을 완벽하게 이해했다면 <code>ECMAScript</code>의 클로저를 쉽게 이해할 수 있다.
<br/></p>
<p>함수 생성 알고리즘에 나와있듯이 <code>ECMAScript</code>의 함수는 부모 콘텍스트의 스코프 체인을 가지고 있기 때문에 모든 함수는 클로저다. 함수의 이후  실행 여부와는 상관없이 함수 생성 시점에 부모의 스코프를 함수의 내부 속성에 저장한다.
<br/></p>
<pre><code class="language-js">var x = 10;

function foo() {
 alert(x);
}

// foo는 클로저다.
foo: &lt;FunctionObject&gt; = {
 [[Call]]: &lt;code block of foo&gt;,
 [[Scope]]: [
   global: {
     x: 10
   }
 ],
 ... // 다른 프로퍼티들
};
</code></pre>
<p>앞에서 언급했듯이, 함수가 자유 변수를 사용하지 않는 경우에는 성능 최적화를 위해 <code>JavaScript</code> 엔진이 부모 스코프 체인을 함수 내부에 저장하지 않을 수도 있다.</p>
<p>그러나 <code>ECMA-262-3</code> 스펙은 이에 대해서 언급하고 있지 않다. 따라서 공식적으로(그리고 기술적 알고리즘에 따라) 모든 함수는 생성 시점에 <code>[[Scope]]</code> 프로퍼티에 스코프 체인을 저장한다.</p>
<p>일부 엔진은 사용자가 클로저 스코프에 직접 접근하는 것을 허용한다.</p>
<a class="header" href="#scope-공유one-scope-value-for-them-all" id="scope-공유one-scope-value-for-them-all"><h2><code>[[Scope]]</code> 공유(One [[Scope]] value for “them all”)</h2></a>
<p><code>ECMAScript</code>에서 같은 부모 콘텍스트에서 만들어진 여러 중첩 함수는 같은 클로저 <code>[[Scope]]</code> 객체를 사용한다. 이는 어떤 클로저가 클로저 변수를 수정하면, 변경한 내용을 다른 클로저가 읽을 수 있다는 의미다.
<br/></p>
<p>즉, 모든 중첩 함수는 같은 부모의 스코프를 공유한다.
<br/></p>
<pre><code class="language-js">var firstClosure;
var secondClosure;

function foo() {
 var x = 1;
 firstClosure = function () { return ++x; };
 secondClosure = function () { return --x; };
 x = 2; // 두 클로저의 [[Scope]] 안에 있는 AO[&quot;x&quot;]에 영향을 준다.
 alert(firstClosure()); // 3. firstClosure.[[Scope]]
}

foo();

alert(firstClosure()); // 4
alert(secondClosure()); // 3
</code></pre>
<p>이와 관련해서 많은 사람들이 자주하는 실수가 있다.  모든 함수가 고유의 루프 카운터 값을 갖게 만들기 위해 루프 안에서 함수를 생성할 때, 의도하지 않은 결과를 얻는 경우가 종종 있다.
<br/></p>
<pre><code class="language-js">var data = [];

for (var k = 0; k &lt; 3; k++) {
 data[k] = function () {
   alert(k);
 };
}

data[0](); // 3, 0이 아니다.
data[1](); // 3, 1이 아니다.
data[2](); // 3, 2가 아니다.
</code></pre>
<p>이전 예제에서 이 동작을 설명했다. 세 함수 모두 같은 콘텍스트의 스코프를 갖는다. 이 세 함수는 모두 <code>[[Scope]]</code> 프로퍼티를 통해 변수를 참조하여 부모 스코프에 존재하는 변수 <code>k</code>를 쉽게 변경할 수 있다.</p>
<pre><code class="language-js">activeContext.Scope = [
 ... // 상위의 변수 객체
 {data: [...], k: 3} // 활성화 객체
];
data[0].[[Scope]] === Scope;
data[1].[[Scope]] === Scope;
data[2].[[Scope]] === Scope;
</code></pre>
<p>따라서 세 함수는 실행 시점에 변수 k에 마지막으로 할당한 값인 3을 사용한다.</p>
<a class="header" href="#클로저의-실제적-사용practical-usage-of-closures" id="클로저의-실제적-사용practical-usage-of-closures"><h2>클로저의 실제적 사용(Practical usage of closures)</h2></a>
<p>실제로 클로저를 이용하면 다양한 계산을 사용자가 함수 전달인자로 정의할 수 있게 하는 우아한 설계를 할 수 있다. 예를 들어 정렬 조건를 함수 전달인자로 받는 배열 정렬 메소드가 있다.</p>
<pre><code class="language-js">[1, 2, 3].sort(function (a, b) {
 ... // 정렬 조건
});
</code></pre>
<p>그리고 인자로 전달받은 함수를 배열의 각 원소에 적용한 결과를 갖는 새로운 배열을 만들어 돌려주는 <code>map</code> 메소드와 같은, 맵핑 고차함수(<code>mapping functionals</code>)가 있다.</p>
<pre><code class="language-js">[1, 2, 3].map(function (element) {
 return element * 2;
}); // [2, 4, 6]
</code></pre>
<p>검색 함수를 만들 때 함수를 전달인자로 받아 거의 무제한적인 검색 조건을 정의할 수 있게 구현해 놓으면 편리하다.</p>
<pre><code class="language-js">someCollection.find(function (element) {
 return element.someProperty == 'searchCondition';
})
</code></pre>
<p>또한, 배열을 순회하면서 각각의 원소에 함수를 적용하는 <code>forEach</code> 메소드와 같은 함수 적용 고차함수(<code>applying functional</code>)도 있다.</p>
<pre><code class="language-js">[1, 2, 3].forEach(function (element) {
 if (element % 2 != 0) {
   alert(element);
 }
}); // 1, 3
</code></pre>
<p>함수 객체의 <code>apply, call</code> 메소드는 함수형 프로그래밍의 함수 적용 고차함수(<code>applying functional</code>)에서 유래했다.
이미 이 메소드에 대해서는 <code>Chapter 3. this</code> 에서 이야기 했으므로, 이번에는 함수를 매개변수에 전달하는 방식을 살펴본다(<code>apply</code> 는 전달인자 목록을 받고, <code>call</code> 은 전달인자를 차례로 나열한다).</p>
<pre><code class="language-js">(function () {
 alert([].join.call(arguments, ';')); // 1;2;3
}).apply(this, [1, 2, 3]);
</code></pre>
<p>프로그래밍에서 <code>apply</code>는 데이터에 임의의 함수를 적용한다는 의미를 가진다. 만약 함수의 이름과 기능이 확정되어 있고, 그것을 알 수 있다면 함수의 이름과 파라미터 형식에 맞춰서 함수를 호출할 수 있다. 그런데 함수형 언어의 함수는 일급 객체로서 데이터로 취급할 수 있기 때문에 함수를 변수에 저장할 수 있고, 다른 함수의 인자로 전달할 수  있으며, 결과 값으로 반환할 수 있다.
<br/></p>
<p>간단히 말해서 함수를 다른 곳으로 넘길 수 있다는 이야기다. 이렇게 함수를 다른 곳으로 넘겼을 때 함수를 받은 쪽에서 받은 함수를  호출할 수 있는 장치가 필요한데, 이 장치를 사용하는 것을 <code>apply</code>라고 한다. <code>JavaScript</code> 역시 함수를 일급 객체로 취급하기 때문에 함수를 <code>apply</code> 하기 위한 <code>call</code>, <code>apply</code> 메소드를 가지고 있다.
<br/></p>
<p>그리고 함수들의 집합을 정의역으로 갖는 함수를 수학 용어로는 범함수(<code>functional</code>)라고 한다.
<br/></p>
<p>지연 호출은 클로저의 또 다른 중요한 응용 사례다.
<br/></p>
<pre><code class="language-js">var a = 10;
setTimeout(function () {
 alert(a); // 10, 1초 후 실행
}, 1000);
</code></pre>
<pre><code class="language-js">var x = 10;
// 예제용
xmlHttpRequestObject.onreadystatechange = function () {
 // 데이터가 준비 되었을 때, 지연 호출하는 콜백.
 // 콜백을 생성한 콘텍스트가 이미 사라졌는지와는 상관없이
 // 여기에서 변수 x에 접근할 수 있다.
 alert(x); // 10
};
</code></pre>
<p>또는 보조 객체를 감추기 위해 캡슐화 한 스코프를 만들 수 있다.</p>
<pre><code class="language-js">var foo = {};
// 초기화
(function (object) {
 var x = 10;
 object.getX = function _getX() {
   return x;
 };
})(foo);
alert(foo.getX()); // 클로저 변수 &quot;x&quot;의 값은 10
</code></pre>
<hr />
<a class="header" href="#reference-4" id="reference-4"><h4>Reference</h4></a>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-Closure/">chapter-6-closure</a></li>
</ul>
<a class="header" href="#es3-1" id="es3-1"><h1>ES3</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
